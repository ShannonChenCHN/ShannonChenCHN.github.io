<!DOCTYPE html><html lang=""><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> [iOS 开发] NSCalendar 这个坑货——获取系统当前时间年份出错 · Shannon's Blog</title><meta name="description" content="[iOS 开发] NSCalendar 这个坑货——获取系统当前时间年份出错 - ShannonChenCHN"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Shannon's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">TAG</a></li><li class="nav-list-item"><a href="https://github.com/ShannonChenCHN" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">[iOS 开发] NSCalendar 这个坑货——获取系统当前时间年份出错</h1><div class="post-info">Jul 3, 2016</div><div class="post-content"><blockquote>
<p>背景：最近 BI 的同学反映，根据我们 iOS 客户端收集的埋点数据显示，<strong>有一部分数据的埋点时间</strong>不对，但是我在工程代码中断点调试时却没有发现任何异常情况。</p>
</blockquote>
<p>BI 同学提供的“证据”如下图所示，图中圈出来的 tracktime （<strong>0028</strong>0629104535）本应显示的时间理应是 <strong>2016</strong>0629104535，机智的 BI 同学分析其原因可能是，我们记录时间的代码在某些机器上可能有问题，也就是说机型适配问题，但根据我多年的开发经验来看（不要笑），问题应该不在于此，其中必定另有蹊跷。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/814356-647545c57db8b16e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="埋点数据.png"><br>于是，我看了一下我们记录埋点时间的相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// tt</span><br><span class="line">NSDateFormatter *dateformatter=[[NSDateFormatter alloc] init];</span><br><span class="line">[dateformatter setDateFormat:@&quot;yyyyMMddHHmmss&quot;];</span><br><span class="line">[mutDict setString:[dateformatter stringFromDate:[NSDate date]] forKey:MTCLICK_KEY_TT];</span><br></pre></td></tr></table></figure></p>
<p>第一眼看上去貌似很正常，打个断点，打印出来的时间也没问题。那么问题在哪呢？难道真是机型问题？但从没听说过机型跟这时间格式有毛关系啊。</p>
<p>那就只能先从 NSDateFormatter 入手了，首先求助于官方文档 Data Formatting Guide，在 Date Formatters 章节中的 Use Format Strings to Specify Custom Formats 发现其中有这样一段话：</p>
<blockquote>
<p> There are two things to note about this example:</p>
<ol>
<li>It uses yyyy to specify the year component. <strong>A common mistake is to use YYYY.</strong> yyyy specifies the calendar year whereas YYYY specifies the year (of “Week of Year”), used in the ISO year-week calendar. In most cases, yyyy and YYYY yield the same number, however they may be different. Typically you should use the calendar year.</li>
</ol>
<p>2.The representation of the time may be 13:00. In iOS, however, if the user has switched 24-Hour Time to Off, the time may be 1:00 pm.</p>
</blockquote>
<p>读到此处，我感慨万分，到处都是坑啊！顿时想起<strong>年初</strong>时的那个优惠券有效期的 bug，就是因为时间格式的年份用了 “YYYY”，而不是 “yyyy”，而导致了一个平时看不出来到跨年的时候才出现的问题。<figure class="highlight plain"><figcaption><span>specifies the calendar year whereas YYYY specifies the year (of “Week of Year”), used in the ISO year-week calendar. ```这句话很关键，由此可以看出之前这个问题的根本就在于日历（calendar）的区别。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现在我们再回过头来看看这次埋点 bug 的“证据”： **2016**0629104535 -&gt; （**0028**0629104535），问题好像也是出在年份上，那么 0028 代表什么呢？于是我先后求助了度娘、stackoverflow、bing，最终在 bing 上找到了这样一篇文章 [How TechCrunch Japan broke our app - Handling local calendars in Swift](http://blog.famanson.com/2016/01/07/handling-local-calendars-is-a-pain/)，里面专门提到了一个关于日本日历（Japan calendar）和公历（Gregorian calendar）之间区别的例子，当我看到这样一段令人感动的话时:</span><br><span class="line">&gt; It means that any NSDate instances retrieved from CoreData would always point to the right point in time, i.e. 04 Jan 0028 in Japan calendar now always points to the same point in time as 04 Jan 2016 in Gregorian calendar (having the same Unix timestamp 1451865600).   </span><br><span class="line"></span><br><span class="line">原来公历2016年相当于日本平成28年，我顿时感觉豁然开朗，仿佛终于找到心目中的 the one 了。</span><br><span class="line">找到问题所在后，接下来就是试验验证了。</span><br><span class="line">还是那段代码：</span><br></pre></td></tr></table></figure></p>
<p>NSDateFormatter *dateformatter=[[NSDateFormatter alloc] init];<br>[dateformatter setDateFormat:@”yyyyMMddHHmmss”];<br>NSLog(@”%@”, [dateformatter stringFromDate:[NSDate date]]);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打开模拟器的设置-&gt;通用-&gt;语言与地区-&gt;日历，我们依次选择“公历”、“日本日历”、“佛教日历”，并运行工程，console 打印出来的结果是如下。</span><br><span class="line"></span><br><span class="line">试验结果说明之前的百分百推断属实。那现在我们该怎么解决这个问题呢？打开 NSDateFormatter.h 文件和参考文档，我们可以看到一个属性 ``@property (null_resettable, copy) NSCalendar *calendar;`` ，然后我们再打开 NSCalendar 类的参考文档，可以看到 ``Calendar Identifiers``常量的一些声明：</span><br></pre></td></tr></table></figure>
<p>NSString <em> const NSCalendarIdentifierGregorian<br>NSString </em> const NSCalendarIdentifierBuddhist<br>NSString <em> const NSCalendarIdentifierChinese<br>NSString </em> const NSCalendarIdentifierCoptic<br>NSString <em> const NSCalendarIdentifierEthiopicAmeteMihret<br>NSString </em> const NSCalendarIdentifierEthiopicAmeteAlem<br>NSString <em> const NSCalendarIdentifierHebrew<br>NSString </em> const NSCalendarIdentifierISO8601<br>NSString <em> const NSCalendarIdentifierIndian<br>NSString </em> const NSCalendarIdentifierIslamic<br>NSString <em> const NSCalendarIdentifierIslamicCivil<br>NSString </em> const NSCalendarIdentifierJapanese<br>NSString <em> const NSCalendarIdentifierPersian<br>NSString </em> const NSCalendarIdentifierRepublicOfChina<br>NSString <em> const NSCalendarIdentifierIslamicTabular<br>NSString </em> const NSCalendarIdentifierIslamicUmmAlQura<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">显而易见的是，这里我们应该选择 NSCalendarIdentifierGregorian（公历）。</span><br></pre></td></tr></table></figure></p>
<p>NSDateFormatter *dateformatter=[[NSDateFormatter alloc] init];<br>[dateformatter setDateFormat:@”yyyyMMddHHmmss”];<br>[dateformatter setCalendar:[NSCalendar calendarWithIdentifier:NSCalendarIdentifierGregorian]];<br>NSLog(@”%@”, [dateformatter stringFromDate:[NSDate date]]);<br>```<br>重新修改代码，再次验证后结果如下。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/814356-d2f00587fcebd7b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公历（Gregorian）.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/814356-931849e9dcbb0812.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="日本日历（Japanese）.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/814356-5366a957d3f41bbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="佛教日历（Buddhist）.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/814356-e355753fb08c4583.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置选项中为日本日历（Japanese），但代码中设了 calendar 属性.png"></p>
<p>试验结果证明设置 NSDateFormatter 对象的 calendar 属性为 identifier 为公历<code>NSCalendarIdentifierGregorian</code>的 NSCalendar 对象就可以解决这个问题了。</p>
<p>NSDateFormatter 是我们经常需要使用的一个类，但在使用过程中需要注意很多有关地区，时间，性能方面的问题，要想知道如何一一避免那些坑，多读官方文档是一个上佳的选择。</p>
<p>One more thing，人蠢就要多读书啦！不然连日本日历是什么都不知道是什么。Just kidding! 😄</p>
<blockquote>
<p>参考资料:<br>（1）How TechCrunch Japan broke our app - Handling local calendars in Swift：<a href="http://blog.famanson.com/2016/01/07/handling-local-calendars-is-a-pain/" target="_blank" rel="noopener">http://blog.famanson.com/2016/01/07/handling-local-calendars-is-a-pain/</a><br>（2）官方文档: Data Formatting Guide</p>
</blockquote>
<hr>
<blockquote>
<p>拓展延伸：</p>
</blockquote>
<p>（1）日历有哪几种？什么是日本日历？什么是佛教日历？<br>（2）如何正确使用 NSDateFormatter ？</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/01/03/2016-review/" class="prev">PREV</a><a href="/2016/05/08/github-search-tips/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">ShannonChenCHN</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>