<!DOCTYPE html><html lang=""><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 一个 iOS 11 自定义导航栏按钮偏移问题的优雅解决方案 · Shannon's Blog</title><meta name="description" content="一个 iOS 11 自定义导航栏按钮偏移问题的优雅解决方案 - ShannonChenCHN"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Shannon's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">TAG</a></li><li class="nav-list-item"><a href="https://github.com/ShannonChenCHN" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">一个 iOS 11 自定义导航栏按钮偏移问题的优雅解决方案</h1><div class="post-info">Feb 9, 2018</div><div class="post-content"><p><a href="https://github.com/ShannonChenCHN/UINavigationBar-IXTouch" target="_blank" rel="noopener">阅读原文</a></p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在 iOS 11 下，UINavigationBar 中左右两侧的自定义按钮，会出现位置受限的问题，我们可以通过在创建 UIBarButtonItem 时设置 custom view 的布局，但是又会出现部分区域不能接收到点击事件。</p>
<a id="more"></a>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>1.创建 UIBarButtonItem 时，设置 UIBarButtonItem 的 custom view，因为 custom view 的位置和大小会被系统限制住，所以可以把这个  custom view 作为一个容器，在其上添加一个 button。</p>
<p>2.因为在 custom view 上添加的 button 有可能在超出 custom view 的 bounds 范围，所以为了保证 button 能够被响应，我们需要将 custom view 上接收到的点击事件传给这个 button。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@implementation IXOutsideTouchView</span><br><span class="line"></span><br><span class="line">// allow touches outside view</span><br><span class="line">// https://github.com/Automattic/simplenote-ios/blob/b43ffb63ae188fe263bf7419e44b7075ea7ddf22/Simplenote/Classes/SPOutsideTouchView.h</span><br><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    </span><br><span class="line">    for(UIView *aSubview in self.subviews) &#123;</span><br><span class="line">        UIView *view = [aSubview hitTest:[self convertPoint:point toView:aSubview] withEvent:event];</span><br><span class="line">        if(view) return view;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>3.在 iOS 11 下，系统的导航栏有一个叫做 <code>_UINavigationBarContentView</code> 的子控件，会把导航栏上的点击事件拦截掉，所以我们需要从 UINavigationBar 的 view 层级中找到我们的 custom view，并在  UINavigationBar 的 <code>hitTest:withEvent:</code> 中将点击事件传给这个 custom view，这样我们的 button 就能接收点击事件了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">NS_INLINE UIView *IXFindIXOutsideTouchViewInView(UIView *view) &#123;</span><br><span class="line">    for (UIView *subview in view.subviews) &#123;</span><br><span class="line"></span><br><span class="line">        if ([subview isKindOfClass:[IXOutsideTouchView class]]) &#123;</span><br><span class="line">            return subview;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            UIView *theView = IXFindIXOutsideTouchViewInView(subview);</span><br><span class="line">            if (theView) &#123;</span><br><span class="line">                return theView;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@implementation IXNavigationBar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    </span><br><span class="line">    // 针对 iOS 11 下按钮点击范围被限制的问题作了修改</span><br><span class="line">    if (@available(iOS 11,*)) &#123;</span><br><span class="line">        </span><br><span class="line">        // 递归遍历所有子 view，直到找到 IXOutsideTouchView，并且该 view 还能响应</span><br><span class="line">        // 1. 一个一个问 subview，是否是 IXOutsideTouchView</span><br><span class="line">        // 2. 如果是，就直接返回，如果不是，就继续问 subview 的 subview，递归询问</span><br><span class="line">        // 3. 如果一直没找到，就什么都不做，继续往下执行</span><br><span class="line">        // 4. 如果最终找到了，就调用 hitTest:withEvent: 方法，询问是否有可响应的 view</span><br><span class="line">        </span><br><span class="line">        UIView *view = IXFindIXOutsideTouchViewInView(self);</span><br><span class="line">        if (view) &#123;</span><br><span class="line">            UIView *finalView = [view hitTest:[self convertPoint:point toView:view] withEvent:event];</span><br><span class="line">            if (finalView) &#123;</span><br><span class="line">                return finalView;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    return [super hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="更优雅的封装"><a href="#更优雅的封装" class="headerlink" title="更优雅的封装"></a>更优雅的封装</h3><p>按照上面的几个步骤，就已经可以实现我们想要达到的目的了，但是 navigation bar 需要知道自定义 view，耦合度比较高，而且还必须要自定义 UINavigationBar 的子类。</p>
<p>所以，我们可以通过 runtime 的 Method Swizzling 技术结合 category 来实现上面的第三步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">typedef UIView *(^IXViewHitTestBlock)(UIView *view);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 在 view 层级中找到指定 class 的 container view 的响应接受者</span><br><span class="line"></span><br><span class="line"> @param customViewClasses 自定义 class</span><br><span class="line"> @param containerView 容器 view</span><br><span class="line"> @param hitTestBlock 是否接收响应事件</span><br><span class="line"> @return 如果找到就返回一个 view，没找到则返回 nil。</span><br><span class="line"> */</span><br><span class="line">NS_INLINE UIView *IXFindTouchEventReceiverForCustomViewInView(NSArray &lt;Class&gt; *customViewClasses, UIView *containerView, IXViewHitTestBlock hitTestBlock) &#123;</span><br><span class="line">   </span><br><span class="line">    for (UIView *subview in containerView.subviews) &#123;</span><br><span class="line">        </span><br><span class="line">        if ([customViewClasses containsObject:subview.class] &amp;&amp; hitTestBlock(subview)) &#123; // 是自定义 view，并且能接收响应</span><br><span class="line">            return hitTestBlock(subview);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果不符合条件，就从 subview 开始找</span><br><span class="line">            UIView *theView = IXFindTouchEventReceiverForCustomViewInView(customViewClasses, subview, hitTestBlock);</span><br><span class="line">            if (theView) &#123;</span><br><span class="line">                return theView;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">@implementation UINavigationBar (IXTouch)</span><br><span class="line"></span><br><span class="line">static NSMutableArray &lt;Class&gt; *m_registeredCustomTouchViewClasses = nil;</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    [self ix_exchangeInstanceMethod1:@selector(hitTest:withEvent:) method2:@selector(ix_hitTest:withEvent:)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)ix_registerCustomTouchViewClass:(Class)viewClass &#123;</span><br><span class="line">    </span><br><span class="line">    if (!m_registeredCustomTouchViewClasses) &#123;</span><br><span class="line">        m_registeredCustomTouchViewClasses = [NSMutableArray array];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [m_registeredCustomTouchViewClasses addObject:viewClass];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 触摸事件是按照这样的顺序传递的： UIApplication -&gt; UIWindow -&gt; root view -&gt; subview -&gt; subview... 直到找到合适的 view</span><br><span class="line">// https://www.jianshu.com/p/2e074db792ba</span><br><span class="line">- (UIView *)ix_hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    </span><br><span class="line">    // 针对 iOS 11 下按钮点击范围被限制的问题作了修改</span><br><span class="line">    if (@available(iOS 11,*)) &#123;</span><br><span class="line">        </span><br><span class="line">        // 递归遍历所有子 view，直到找到 IXOutsideTouchView，并且该 view 还能响应</span><br><span class="line">        // 1. 一个一个问 subview，是否是 IXOutsideTouchView</span><br><span class="line">        // 2. 如果是，就直接返回，如果不是，就继续问 subview 的 subview，递归询问</span><br><span class="line">        // 3. 如果一直没找到，就什么都不做，继续往下执行</span><br><span class="line">        // 4. 如果最终找到了，就调用 hitTest:withEvent: 方法，询问是否有可响应的 view</span><br><span class="line">        </span><br><span class="line">        UIView *view = IXFindTouchEventReceiverForCustomViewInView(m_registeredCustomTouchViewClasses, self, ^(UIView *aView)&#123;</span><br><span class="line">            return [aView hitTest:[self convertPoint:point toView:aView] withEvent:event];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        if (view) return view;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return [self ix_hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>当需要为自定义导航栏按钮拦截点击事件时，只需要注册这个 view 的 class 就行了。而且，如果你在导航上使用了多个不同类的 custom view，会按照注册先后顺序进行询问，只有最先注册的而且能做出响应的（响应范围合法）才会接收到点击事件。</p>
<p>将上面几个步骤合起来，再用 UIBarButtonItem 的 category 进行封装，就是这样的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)leftItemWithImage:(UIImage *)image imageEdgeInsets:(UIEdgeInsets)insets target:(id)target action:(SEL)action &#123;</span><br><span class="line">    </span><br><span class="line">    // 这个按钮才是真正要响应点击事件的控件</span><br><span class="line">    UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(-kImageBarButtonSidePadding, 0, kNavigationBarHeight, kNavigationBarHeight)];</span><br><span class="line">    [button setImage:image forState:UIControlStateNormal];</span><br><span class="line">    button.imageEdgeInsets = insets;</span><br><span class="line">    [button addTarget:target action:action forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    </span><br><span class="line">    // 包装 button 的容器 view，这个 view 的位置和大小被限制死了，所以还需要把触摸事件传给 button</span><br><span class="line">    IXOutsideTouchView *containerView = [[IXOutsideTouchView alloc] initWithFrame:CGRectMake(0, 0, kNavigationBarHeight, kNavigationBarHeight)];</span><br><span class="line">    [containerView addSubview:button];</span><br><span class="line">    </span><br><span class="line">    // iOS 11 下的适配，将 UINavigationBar 上的触摸事件传到最上面的自定义控件，防止被系统的 _UINavigationBarContentView 拦截掉</span><br><span class="line">    [UINavigationBar ix_registerCustomTouchViewClass:[IXOutsideTouchView class]];</span><br><span class="line">    </span><br><span class="line">    UIBarButtonItem *item = [[UIBarButtonItem alloc] initWithCustomView:containerView];</span><br><span class="line">    </span><br><span class="line">    return item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细的实现见 <a href="https://github.com/ShannonChenCHN/UINavigationBar-IXTouch/tree/master/Classes" target="_blank" rel="noopener">源代码</a>。</p>
<h3 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">self.navigationItem.leftBarButtonItem = [UIBarButtonItem leftItemWithImage:[UIImage imageNamed:@&quot;navigationbar_back_black&quot;]</span><br><span class="line">                                                           imageEdgeInsets:UIEdgeInsetsZero</span><br><span class="line">                                                                    target:self</span><br><span class="line">                                                                    action:@selector(pop)];</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://github.com/Automattic/simplenote-ios/blob/b43ffb63ae188fe263bf7419e44b7075ea7ddf22/Simplenote/Classes/SPOutsideTouchView.h" target="_blank" rel="noopener">Automattic/Simplenote/Classes/SPOutsideTouchView.h</a></li>
<li><a href="http://nshipster.cn/method-swizzling/" target="_blank" rel="noopener">Method Swizzling - NSHipster</a></li>
<li><a href="https://www.jianshu.com/p/2e074db792ba" target="_blank" rel="noopener">史上最详细的iOS之事件的传递和响应机制-原理篇</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/02/12/2018-02-12/" class="prev">上一篇</a><a href="/2018/02/08/2018-02-08/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">ShannonChenCHN</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>