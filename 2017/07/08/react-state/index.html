<!DOCTYPE html><html lang=""><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> [React Native] React 中的状态（State） · Shannon's Blog</title><meta name="description" content="[React Native] React 中的状态（State） - ShannonChenCHN"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Shannon's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">TAG</a></li><li class="nav-list-item"><a href="https://github.com/ShannonChenCHN" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">[React Native] React 中的状态（State）</h1><div class="post-info">Jul 8, 2017</div><div class="post-content"><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>1.<code>state</code> 属性<ul>
<li>1.1 <code>state</code>属性的介绍</li>
<li>1.2 <code>state</code> 的使用</li>
</ul>
</li>
<li>2.<code>setState()</code> 方法<ul>
<li>2.1 第一个参数：<code>updater</code> 函数</li>
<li>2.2 第二个参数：<code>callback</code> </li>
</ul>
</li>
<li>3.正确操作 state<ul>
<li>3.1 不要使用 <code>this.state</code> 来直接修改 <code>state</code></li>
<li>3.2 状态更新可能是异步的</li>
<li>3.3 状态更新是一个合并的过程</li>
</ul>
</li>
<li>4.单向数据流</li>
<li>5.完整示例代码</li>
</ul>
<p><code>state</code> 属性是 React 组件用来更新数据的核心特性，也是我们平时见得最多的属性之一，那么你对 <code>state</code> 又了解多少呢？</p>
<h3 id="1-state-属性"><a href="#1-state-属性" class="headerlink" title="1. state 属性"></a>1. <code>state</code> 属性</h3><h4 id="1-1-state属性的介绍"><a href="#1-1-state属性的介绍" class="headerlink" title="1.1 state属性的介绍"></a>1.1 <code>state</code>属性的介绍</h4><p>我们使用两种数据来控制一个组件：<code>props</code> 和 <code>state</code>。<code>props</code> 是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。 对于需要改变的数据，我们需要使用 <code>state</code>。</p>
<p><code>state</code> 属性主要用来存储组件自身需要的数据，是组件自己私有的，我们一般通过修改 <code>state</code> 属性的值来更新数据，React 内部会监听 <code>state</code> 的变化，一旦发生变化就会主动触发组件的 <code>render()</code> 方法来更新 Dom 结构。</p>
<p><code>state</code> 应该是一个 JavaScript 对象。</p>
<h4 id="1-2-state-的使用"><a href="#1-2-state-的使用" class="headerlink" title="1.2 state 的使用"></a>1.2 <code>state</code> 的使用</h4><p>一般来说，你需要在 <code>constructor()</code> 方法中初始化 <code>state</code>（这是ES6的写法，ES5 中一般在 <code>getInitialState()</code> 方法中来初始化 <code>state</code>），然后在需要修改时调用 <code>setState()</code> 方法。</p>
<p>不要使用 <code>this.state</code> 来修改 <code>state</code> 属性值，应该调用 <code>setState()</code> 方法，<code>this.state</code> 是不可变的。</p>
<h3 id="2-setState-方法"><a href="#2-setState-方法" class="headerlink" title="2. setState() 方法"></a>2. <code>setState()</code> 方法</h3><p><code>setState()</code> 的完整表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState(updater, [callback])</span><br></pre></td></tr></table></figure></p>
<p><code>setState()</code> 方法会把对组件 state 的改变加入到队列中，并且告诉 React 这个组件及其子组件需要重新渲染。</p>
<h4 id="2-1-第一个参数：updater-函数"><a href="#2-1-第一个参数：updater-函数" class="headerlink" title="2.1 第一个参数：updater 函数"></a>2.1 第一个参数：<code>updater</code> 函数</h4><p><code>setState(updater, callback)</code> 方法的第一个参数是一个固定格式的 <code>updater</code> 函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(prevState, props) =&gt; stateChange</span><br></pre></td></tr></table></figure></p>
<p><code>prevState</code> 是一个对之前状态（previous state）的引用，我们是不能直接修改这个参数的值，要想修改 <code>state</code> 的值，我们应该根据 <code>prevState</code> 和 <code>props</code> 参数来创建一个新的 JavaScript 对象。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState((prevState, props) =&gt; &#123;</span><br><span class="line">  return &#123;counter: prevState.counter + props.step&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>你也可以传一个对象而不是函数，来作为<code>setState(updater, callback)</code> 方法的第一个参数，React 会将该参数 merge 到 state 中。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;quantity: 2&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="2-2-第二个参数：callback"><a href="#2-2-第二个参数：callback" class="headerlink" title="2.2 第二个参数：callback"></a>2.2 第二个参数：<code>callback</code></h4><p><code>setState(updater, callback)</code> 方法的第二个参数 <code>callback</code> 是一个可选参数。</p>
<p>为了更好的性能表现，React 并不能保证 <code>setState()</code> 一被调用 state 就能更新。所以，如果在调用 <code>setState()</code> 之后，马上就读取 <code>this.state</code> 的值的话，可能会出现误差。<br>因此，这种情况下，推荐使用 <code>componentDidUpdate</code> 或者 <code>setState(updater, callback)</code> 方法的 <code>callback</code> 来获取最新的状态。React 官方更推荐使用 <code>componentDidUpdate()</code>，而不是 <code>callback</code> 来监听 update 事件（注： 除非 <code>shouldComponentUpdate()</code> 方法返回 <code>false</code>，<code>setState()</code> 将永远都会引发重新渲染）。</p>
<h3 id="3-正确操作-state"><a href="#3-正确操作-state" class="headerlink" title="3. 正确操作 state"></a>3. 正确操作 state</h3><h4 id="3-1-不要使用-this-state-来直接修改-state"><a href="#3-1-不要使用-this-state-来直接修改-state" class="headerlink" title="3.1 不要使用 this.state 来直接修改 state"></a>3.1 不要使用 <code>this.state</code> 来直接修改 <code>state</code></h4><blockquote>
<p>记住，<code>this.state</code> 是不可变的。</p>
</blockquote>
<p>不要使用 <code>this.state</code> 来修改 <code>state</code> 属性值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Wrong</span><br><span class="line">this.state.comment = &apos;Hello&apos;;</span><br></pre></td></tr></table></figure>
<p>应该调用 <code>setState()</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Correct</span><br><span class="line">this.setState(&#123;comment: &apos;Hello&apos;&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="3-2-状态更新可能是异步的"><a href="#3-2-状态更新可能是异步的" class="headerlink" title="3.2 状态更新可能是异步的"></a>3.2 状态更新可能是异步的</h4><p>考虑到性能问题，如果在同一个周期内，调用了多次，React 可能会将多个 <code>setState()</code> 方法的调用批量合成一次更新。比如，你在一个周期内，对一个数值进行多次累加，就会出现类似于下面的这种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(</span><br><span class="line">  previousState,</span><br><span class="line">  &#123;quantity: state.quantity + 1&#125;,</span><br><span class="line">  &#123;quantity: state.quantity + 1&#125;,</span><br><span class="line">  ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>这也就意味着，后面的调用会覆盖掉上一次调用后的修改的 state 值，因此 quantity 只累加了 1 次。</p>
<p>考虑到 <code>this.props</code> 和<code>this.state</code> 可能是异步更新的，所以，每次调用 <code>setState()</code> 方法时，最好不要依赖于 <code>this.props</code> 和<code>this.state</code> 来计算最新的 <code>state</code>。</p>
<p>总之，如果后面的状态依赖于之前的状态，建议使用 <code>updater</code> 函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Correct</span><br><span class="line">this.setState((prevState, props) =&gt; &#123;</span><br><span class="line">  return &#123;quantity: prevState.quantity + 1&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面用的是 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a> 的形式，其实用普通的函数也是一样的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Correct</span><br><span class="line">this.setState(function(prevState, props) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    quantity: prevState.quantity + 1;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-状态更新是一个合并的过程"><a href="#3-3-状态更新是一个合并的过程" class="headerlink" title="3.3 状态更新是一个合并的过程"></a>3.3 状态更新是一个合并的过程</h4><p>当你调用 <code>setState()</code> 方法时，React 会将将你当前所提供的对象合并到当前的状态中。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      posts: [],</span><br><span class="line">      comments: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line"></span><br><span class="line">    fetchComments().then(response =&gt; &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        comments: response.comments</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面👆的例子中， state 的更新只是替换了 <code>comments</code>，<code>posts</code>是不会受到任何影响的。</p>
<h3 id="4-单向数据流"><a href="#4-单向数据流" class="headerlink" title="4.单向数据流"></a>4.单向数据流</h3><p>父组件和子组件之间不能通过 state 来交互，父组件只能将自己的 state 值传给子组件的 props。这种数据传递的方式通常被称为 “自顶向下（top-down）”或者“单向（unidirectional）”数据流。</p>
<p>任何 state 都是由一个特定的组件所拥有的，任何由 state 驱动的数据或者 UI 只会影响到该组件的子组件。</p>
<p>如果你将组件树想象成一个 props 瀑布，那么每个组件的状态就像是那个组件水源上的附属品，但是也是向下流动的。</p>
<h3 id="5-完整示例代码"><a href="#5-完整示例代码" class="headerlink" title="5. 完整示例代码"></a>5. 完整示例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">import React, &#123; Component, &#125; from &apos;react&apos;;</span><br><span class="line">import &#123;</span><br><span class="line">  AppRegistry,</span><br><span class="line">  StyleSheet,</span><br><span class="line">  View,</span><br><span class="line">  Text,</span><br><span class="line">  TouchableOpacity,</span><br><span class="line">&#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class StateDemo extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;Container style=&#123;styles.container&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Container extends Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    // 设置初始状态</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      showText: true,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">      // 根据状态决定展示什么文字</span><br><span class="line">      var text = (this.state.showText == true) ? &apos;Hello&apos; : &quot;&quot;;</span><br><span class="line">      var buttonTitle = (this.state.showText == true) ? &apos;Hide&apos; : &quot;Show&quot;;</span><br><span class="line"></span><br><span class="line">      return (</span><br><span class="line">        &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">          &lt;Text style=&#123;styles.text&#125;&gt;&#123;text&#125;&lt;/Text&gt;</span><br><span class="line">          &lt;TouchableOpacity</span><br><span class="line">            onPress = &#123;() =&gt; &#123;</span><br><span class="line">             // 更新状态</span><br><span class="line">              this.setState(</span><br><span class="line">                previousState =&gt; &#123;</span><br><span class="line">                  return &#123; showText: !previousState.showText &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">              );</span><br><span class="line"></span><br><span class="line">            &#125;&#125;&gt;</span><br><span class="line">            &lt;Text style=&#123;styles.buttonTitle&#125;&gt;&#123;buttonTitle&#125;&lt;/Text&gt;</span><br><span class="line">          &lt;/TouchableOpacity&gt;</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">  );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> const styles = StyleSheet.create(&#123;</span><br><span class="line">   container: &#123;</span><br><span class="line">     flex: 1,</span><br><span class="line">     backgroundColor: &apos;yellow&apos;,</span><br><span class="line">     alignItems: &apos;center&apos;,</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   text: &#123;</span><br><span class="line">     marginTop: 200,</span><br><span class="line">     fontSize: 30,</span><br><span class="line">     textAlign: &apos;center&apos;,</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   buttonTitle: &#123;</span><br><span class="line">     width: 70,</span><br><span class="line">     marginTop: 10,</span><br><span class="line">     fontSize: 20,</span><br><span class="line">     textAlign: &apos;center&apos;,</span><br><span class="line">     backgroundColor: &apos;green&apos;,</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><ul>
<li><a href="https://facebook.github.io/react/docs/react-component.html" target="_blank" rel="noopener">React API Reference: React.Component</a></li>
<li><a href="https://facebook.github.io/react/docs/state-and-lifecycle.html" target="_blank" rel="noopener">React API Reference: State and Lifecycle</a></li>
<li><a href="http://reactnative.cn/docs/0.45/state.html#content" target="_blank" rel="noopener">React Native 官方文档：State</a></li>
<li>《React Native 入门与实战》</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2017/07/08/react-components-props/" class="prev">PREV</a><a href="/2017/07/08/2017-half-review/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">ShannonChenCHN</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>