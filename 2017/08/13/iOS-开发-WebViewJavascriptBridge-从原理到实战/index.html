<!DOCTYPE html><html lang=""><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> [iOS 开发] WebViewJavascriptBridge 从原理到实战 · Shannon's Blog</title><meta name="description" content="[iOS 开发] WebViewJavascriptBridge 从原理到实战 - ShannonChenCHN"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Shannon's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">TAG</a></li><li class="nav-list-item"><a href="https://github.com/ShannonChenCHN" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">[iOS 开发] WebViewJavascriptBridge 从原理到实战</h1><div class="post-info">Aug 13, 2017</div><div class="post-content"><blockquote>
<p><strong>前言</strong>：iOS 开发中，h5 和原生实现通信有<a href="">多种方式</a>， JSBridge 就是最常用的一种，各 JSBridge 类库的实现原理大同小异，这篇文章主要是针对当前使用最为广泛的 <a href="https://github.com/marcuswestin/WebViewJavascriptBridge/tree/v6.0.2" target="_blank" rel="noopener">WebViewJavascriptBridge（v6.0.2）</a>，从功能 API、实现原理到源码解读、最佳实践，做一个简单介绍。</p>
</blockquote>
<a id="more"></a>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>一、简介<ul>
<li>1.设计目的</li>
<li>2.特点</li>
<li>3.安装、导入</li>
<li>4.API</li>
</ul>
</li>
<li>二、实现原理<ul>
<li>1.目录结构</li>
<li>2.主要流程<ul>
<li>2.1 初始化</li>
<li>2.2 JS 调用原生</li>
<li>2.3 原生调用 JS</li>
<li>2.4 小结</li>
</ul>
</li>
</ul>
</li>
<li>三、源码解读</li>
<li>四、最佳实践<ul>
<li>1.JS 端的优化</li>
<li>2.Objective-C 端的优化</li>
</ul>
</li>
<li>五、问题与讨论</li>
<li>六、延伸阅读</li>
</ul>
<blockquote>
<p><strong>长文警告</strong>：由于文章篇幅较长，如果你不需要了解太多细节的话，可以忽略掉第三部分『源码解读』，通过阅读第二部分『实现原理』（含流程图）就基本可以了解到整个核心流程了（大图加载会比较慢，建议到电脑上阅读）。</p>
</blockquote>
<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><h4 id="1-设计目的"><a href="#1-设计目的" class="headerlink" title="1. 设计目的"></a>1. 设计目的</h4><p>我们平时使用 <code>UIWebView</code> 时，原生和 JavaScript 的交互一般是通过以下两种方式实现的：</p>
<ul>
<li>Native to JavaScript：原生通过 <code>-stringByEvaluatingJavaScriptFromString:</code> 方法执行一段 JavaScript</li>
<li>JavaScript to Native：在网页中加载一个 Custom URL Scheme 的链接（直接设置 window.location 或者新建一个 iframe 去加载这个 URL），原生中拦截 <code>UIWebView</code> 的代理方法 <code>- webView:shouldStartLoadWithRequest:navigationType:</code>，然后根据约定好的协议做相应的处理</li>
</ul>
<p>这两种方式的弊端在于代码过于松散，长而久之，<code>- webView:shouldStartLoadWithRequest:navigationType:</code> 方法变得越来越臃肿杂乱，就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)webView:(UIWebView*)webView shouldStartLoadWithRequest:(NSURLRequest*)request navigationType:(UIWebViewNavigationType)navigationType &#123;</span><br><span class="line">    NSString *urlString = request.URL.absoluteString;</span><br><span class="line">    NSDictionary *params = [[NSDictionary alloc] init];</span><br><span class="line">    </span><br><span class="line">    if (request.URL.query.length &gt; 0) &#123;</span><br><span class="line">        params = [request.URL.query sc_URLParamKeyValues];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ([urlString rangeOfString:@&quot;app://share&quot;].location != NSNotFound) &#123;</span><br><span class="line">           </span><br><span class="line">          // 处理分享逻辑的代码</span><br><span class="line">          return NO;</span><br><span class="line">    &#125; else if ([urlString rangeOfString:@&quot;app://getLocation&quot;].location != NSNotFound) &#123;</span><br><span class="line">           // 获取地理位置的代码...</span><br><span class="line">           // 回调 JS</span><br><span class="line">           [webView stringByEvaluatingJavaScriptFromString:[NSString stringWithFormat:&quot;setLocation(&apos;%@&apos;)&quot;, locationString]];</span><br><span class="line">          return NO;</span><br><span class="line"></span><br><span class="line">    &#125;   else if  ...  </span><br><span class="line">       // 几十个 else if</span><br><span class="line">      else &#123;</span><br><span class="line">          return YES;</span><br><span class="line">    &#125;</span><br><span class="line">          return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>WebViewJavascriptBridge</code> 框架提供了一种更优雅的方式，用来在 <code>WKWebView</code>、<code>UIWebView</code>（iOS） 以及 <code>WebView</code>（OSX）中，建立一个 Objective-C 和 JavaScript 之间互相“发送消息”的机制，让我们可以在 JS 中像直接调 JS 方法那样发消息给 Objective-C，同时可以在 Objective-C 中像直接调 Objective-C 方法那样发消息给 JS。</p>
<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4><ul>
<li>Objective-C 中发送消息给 web view 中的 JavaScript</li>
<li>web view 中的 JavaScript 发送消息给 Objective-C</li>
<li>不论是原生还是 JavaScript，发送消息的过程就像平时调用同一语言/环境的方法一样简单</li>
<li>发送消息时不仅可以带参数，还可以传 callback 用于回调</li>
</ul>
<h4 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h4><p>3.1 使用 pod 安装<br>直接在 podfile 中加入下面这行代码，并执行 <code>pod install</code> 命令：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'WebViewJavascriptBridge'</span>, <span class="string">'~&gt; 6.0'</span></span><br></pre></td></tr></table></figure></p>
<p>3.2 手动导入<br>在 WebViewJavascriptBridge 的 <a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">GitHub repository</a> 上下载源码后，从下载好的文件中将 <code>WebViewJavascriptBridge</code> 文件夹直接拖入你的工程中。</p>
<h4 id="4-API"><a href="#4-API" class="headerlink" title="4. API"></a>4. API</h4><h4 id="4-1-Objective-C-API"><a href="#4-1-Objective-C-API" class="headerlink" title="4.1 Objective-C API"></a>4.1 Objective-C API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 为指定的 web view （WKWebView/UIWebView/WebView）创建一个 JavaScript Bridge </span><br><span class="line">+ (instancetype)bridgeForWebView:(id)webView;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 注册一个名称为 handlerName 的 handler 给 JavaScript 调用</span><br><span class="line">// 当在 JavaScript  中调用 WebViewJavascriptBridge.callHandler(&quot;handlerName&quot;)  时，该方法的 WVJBHandler 参数会收到回调</span><br><span class="line">- (void)registerHandler:(NSString*)handlerName handler:(WVJBHandler)handler;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 调用 JavaScript 中注册过的 handler</span><br><span class="line">// data 参数为调用 handler 时要传递给 JavaScript 的参数，responseCallback 传给 JavaScript 用来回调</span><br><span class="line">- (void)callHandler:(NSString*)handlerName;</span><br><span class="line">- (void)callHandler:(NSString*)handlerName data:(id)data;</span><br><span class="line">- (void)callHandler:(NSString*)handlerName data:(id)data responseCallback:(WVJBResponseCallback)responseCallback;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 如果你需要监听 web view 的代理方法的回调，可以通过该方法设置你的 delegate</span><br><span class="line">- (void)setWebViewDelegate:(id)webViewDelegate;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-JavaScript-API"><a href="#4-2-JavaScript-API" class="headerlink" title="4.2 JavaScript API"></a>4.2 JavaScript API</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个  handler 给 Objective-C 调用</span></span><br><span class="line">registerHandler(handlerName: <span class="built_in">String</span>, <span class="attr">handler</span>: <span class="function"><span class="keyword">function</span>);</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 Objective-C 中注册过的 handler</span></span><br><span class="line">callHandler(handlerName: <span class="built_in">String</span>);</span><br><span class="line">callHandler(handlerName: <span class="built_in">String</span>, <span class="attr">data</span>: <span class="literal">undefined</span>);</span><br><span class="line">callHandler(handlerName: <span class="built_in">String</span>, <span class="attr">data</span>: <span class="literal">undefined</span>, <span class="attr">responseCallback</span>: <span class="function"><span class="keyword">function</span>);</span></span><br></pre></td></tr></table></figure>
<h4 id="5-基本用法"><a href="#5-基本用法" class="headerlink" title="5. 基本用法"></a>5. 基本用法</h4><p>5.1 导入头文件，声明一个 <code>WebViewJavascriptBridge</code> 属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;WebViewJavascriptBridge.h&quot;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">@property WebViewJavascriptBridge* bridge;</span><br></pre></td></tr></table></figure></p>
<p>5.2 为你的 <code>WKWebView</code>、<code>UIWebView</code> (iOS)或者<code>WebView</code> (OSX) 创建一个 <code>WebViewJavascriptBridge</code> 对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.bridge = [WebViewJavascriptBridge bridgeForWebView:webView];</span><br></pre></td></tr></table></figure></p>
<p>5.3 在 Objective-C 中注册 handler 和调用 JavaScript 中的 handler：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[self.bridge registerHandler:@&quot;ObjC Echo&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;</span><br><span class="line">	NSLog(@&quot;ObjC Echo called with: %@&quot;, data);</span><br><span class="line">	responseCallback(data);</span><br><span class="line">&#125;];</span><br><span class="line">[self.bridge callHandler:@&quot;JS Echo&quot; data:nil responseCallback:^(id responseData) &#123;</span><br><span class="line">	NSLog(@&quot;ObjC received response: %@&quot;, responseData);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>5.4 复制下面的 <code>setupWebViewJavascriptBridge</code> 函数到你的 JavaScript 代码中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupWebViewJavascriptBridge</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">window</span>.WebViewJavascriptBridge) &#123; <span class="keyword">return</span> callback(WebViewJavascriptBridge); &#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">window</span>.WVJBCallbacks) &#123; <span class="keyword">return</span> <span class="built_in">window</span>.WVJBCallbacks.push(callback); &#125;</span><br><span class="line">	<span class="built_in">window</span>.WVJBCallbacks = [callback];</span><br><span class="line">	<span class="keyword">var</span> WVJBIframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">	WVJBIframe.style.display = <span class="string">'none'</span>;</span><br><span class="line">	WVJBIframe.src = <span class="string">'https://__bridge_loaded__'</span>;</span><br><span class="line">	<span class="built_in">document</span>.documentElement.appendChild(WVJBIframe);</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">document</span>.documentElement.removeChild(WVJBIframe) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.5 调用 <code>setupWebViewJavascriptBridge</code> 函数，使用 <code>bridge</code> 来注册 handler 和调用 Objective-C 中的 handler：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setupWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span>(<span class="params">bridge</span>) </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 在这里做一些初始化操作 */</span></span><br><span class="line"></span><br><span class="line">	bridge.registerHandler(<span class="string">'JS Echo'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data, responseCallback</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"JS Echo called with:"</span>, data)</span><br><span class="line">		responseCallback(data)</span><br><span class="line">	&#125;)</span><br><span class="line">	bridge.callHandler(<span class="string">'ObjC Echo'</span>, &#123;<span class="string">'key'</span>:<span class="string">'value'</span>&#125;, <span class="function"><span class="keyword">function</span> <span class="title">responseCallback</span>(<span class="params">responseData</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"JS received response:"</span>, responseData)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h3><h4 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1. 目录结构"></a>1. 目录结构</h4><table>
<thead>
<tr>
<th>类名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WebViewJavascriptBridgeBase</code></td>
<td>① 用来进行 bridge 初始化和消息处理的核心类；<br> ② 这个类是在支持 <code>WKWebView</code> 后从  <code>WebViewJavascriptBridge</code> 中独立出来的逻辑，专门用来处理 bridge 相关的逻辑，不再与具体的 Web View 相关联了</td>
<td></td>
</tr>
<tr>
<td><code>WebViewJavascriptBridge</code></td>
<td>① 桥接的入口，针对不同类型的 Web View （<code>UIWebView</code>、<code>WKWebView</code>、<code>WebView</code>）进行分发；<br> ② 针对 <code>UIWebView</code> 和 <code>WebView</code> 做的一层封装，主要用来执行 JS 代码，以及实现 <code>UIWebView</code> 和 <code>WebView</code>的代理方法，并通过拦截 URL 来通知 <code>WebViewJavascriptBridgeBase</code> 做相应操作</td>
<td></td>
</tr>
<tr>
<td><code>WKWebViewJavascriptBridge</code></td>
<td>针对 <code>WKWebView</code> 做的一层封装，主要用来执行 JS 代码，以及实现 <code>WKWebView</code> 的代理方法，并通过拦截 URL 来通知 <code>WebViewJavascriptBridgeBase</code> 做相应操作</td>
<td></td>
</tr>
<tr>
<td><code>WebViewJavascriptBridge_JS</code></td>
<td>JS 端负责“收发消息”的代码</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="2-主要流程"><a href="#2-主要流程" class="headerlink" title="2. 主要流程"></a>2. 主要流程</h4><blockquote>
<p><strong>说明</strong>：<code>WebViewJavascriptBridge</code> 中虽然对不同类型的 Web View 做了不同的处理，但是核心逻辑还是一样的，为了简单说明，这里只讨论 <code>UIWebView</code> 情况下的逻辑。</p>
</blockquote>
<p><code>WebViewJavascriptBridge</code> 参与交互的流程包括三个部分：初始化、JS 调用原生、原生调用 JS。</p>
<h4 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h4><p>WebViewJavascriptBridge 的初始化分为两部分，一部分是 Objective-C 中的 <code>WebViewJavascriptBridge</code> 对象的初始化，另一部分是 JavaScript 中的 <code>window.WebViewJavascriptBridge</code> 的初始化。<br>最终的目标是， Objective-C 和 JavaScript 两边各有一个 <code>WebViewJavascriptBridge</code> 对象，有了这两个对象，两边都可以收发“消息”，同时两边还各自维护一个管理响应事件的 messageHandlers 容器、一个管理回调的 callbackId 容器。<br>所以，我们这里讨论的初始化，不单单是一个对象的初始化，而是一个完整的准备过程，如下图所示。</p>
<p><img src="https://coding.net/u/ShannonChen/p/Static-Resources/git/raw/master/%25E5%2588%259D%25E5%25A7%258B%25E5%258C%2596_01.png" alt="原生部分的初始化.png"></p>
<p><img src="https://coding.net/u/ShannonChen/p/Static-Resources/git/raw/master/%25E5%2588%259D%25E5%25A7%258B%25E5%258C%2596_02.png" alt="JavaScript 部分的初始化.png"><br><strong>（1）</strong>  Objective-C 中的初始化</p>
<ul>
<li>初始化 UIWebView</li>
<li>初始化 WebViewJavascriptBridge，设置 web view 代理</li>
<li>初始化 WebViewJavascriptBridgeBase，初始化相关的属性</li>
</ul>
<p><strong>（2）</strong> 注册 handler 供 JS 调用——把注册过的 handler 保存起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[self.bridge registerHandler:@&quot;share&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;</span><br><span class="line">        NSString *shareContent = [NSString stringWithFormat:@&quot;标题：%@\n 内容：%@ \n url：%@&quot;,</span><br><span class="line">                                  data[@&quot;title&quot;],</span><br><span class="line">                                  data[@&quot;content&quot;],</span><br><span class="line">                                  data[@&quot;url&quot;]];</span><br><span class="line">		 responseCallback(@&quot;分享成功&quot;);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p><strong>（3）</strong> Objective-C 中通过调用 <code>UIWebView</code> 的 <code>loadRequest:</code> 方法加载 URL</p>
<p><strong>（4）</strong> 网页一加载就会执行 web 页中的 bridge 初始化代码，也就是调用上面提到的 <code>setupWebViewJavascriptBridge(bridge)</code>函数</p>
<ul>
<li>保存要执行的自定义初始化函数，比如注册 JS 中的 handler</li>
<li>通过添加一个 iframe 加载初始化链接 <code>https://__bridge_loaded__</code></li>
</ul>
<p><strong>（5）</strong> 原生 WebViewJavascriptBridge 类中代理方法会拦截 <code>https://__bridge_loaded__</code> 的加载</p>
<ul>
<li>在 web view 中执行本地 WebViewJavascriptBridge_JS.m 文件中的代码，初始化 <code>window.WebViewJavascriptBridge</code> 对象：<ul>
<li>在 JS 中创建一个 <code>WebViewJavascriptBridge</code> 对象，并设置成 <code>window</code> 的一个属性</li>
<li>定义几个用于管理消息的全局变量</li>
<li>给 <code>WebViewJavascriptBridge</code> 对象定义几个处理消息的方法和函数</li>
</ul>
</li>
<li>执行原生端 <code>startupMessageQueue</code> 中保存的消息，也就是本地 JS 文件还未加载时就发送了的消息</li>
</ul>
<p><strong>（6）</strong> 初始化完毕</p>
<h4 id="2-2-JS-调用原生"><a href="#2-2-JS-调用原生" class="headerlink" title="2.2 JS 调用原生"></a>2.2 JS 调用原生</h4><p><img src="https://coding.net/u/ShannonChen/p/Static-Resources/git/raw/master/%25E6%25B5%2581%25E7%25A8%258B%25E5%259B%25BE_01.png" alt="JS 调用原生.png"></p>
<p>实际上，相比 原生调用 JS，JS 调用原生的逻辑更婉转，对照上面的示意图，我们可以把JS 调用原生的逻辑简化成以下五个环节：</p>
<ul>
<li>JS 中调用 <code>callHandler()</code> 方法，发消息给原生</li>
<li>在 JS 中将参数和回调包装成一个 message</li>
<li>JS 通知原生到它那边去取 message</li>
<li>原生处理 message 中的数据</li>
<li>原生回调 JS</li>
</ul>
<p><strong>（1）JS 中调用 <code>callHandler()</code> 方法，发消息给原生</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WebViewJavascriptBridge.callHandler(@&quot;share&quot;,</span><br><span class="line">									&#123;title: &quot;标题&quot;&#125;,</span><br><span class="line">								    function (response) &#123;</span><br><span class="line">									   console.log(response);</span><br><span class="line">                                    &#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>（2）在 JS 中将参数和回调包装成一个 message</strong><br>把要调用的 <code>handlerName</code>、要传给 native 的数据 data 以及原生回调 JS 的 <code>responseCallback</code> 对应的 id 包装成一个 message，然后再保存到一个全局的数组 <code>sendMessageQueue</code> 里面。</p>
<p>值得注意的是，那个用于处理原生回调的 <code>responseCallback</code> 是一个函数，是不能直接传给原生的，所以这里只传了其对应的 id，而 <code>responseCallback</code> 本身会被存到一个全局的 <code>responseCallbacks</code> 对象的属性里面去，属性名就是 <code>responseCallback</code> 对应的 id。原生回调 JS 时，就会根据 id 从 <code>responseCallbacks</code> 对象中去取对应的 callback。</p>
<p><strong>（3）JS 通知原生到它那边去取 message</strong><br>在 iframe 中加载发送消息的 URL，通知原生“我 JS 发消息给你了，麻烦你到信箱里查收一下”，原生中的 <code>WebViewJavascriptBridge</code> 就会在 webView 代理方法里面拦截到这个事件，然后再调用 JS，将 <code>sendMessageQueue</code> 中的 message 全部取出来，然后转成 JSON string 的形式。</p>
<p><strong>（4） 原生处理 message 中的数据</strong><br>原生拿到转为 JSON string 的 message 之后，先将其解析成原生的字典，然后再取出 <code>data</code>、 <code>callbackId</code> 和 <code>handlerName</code>，最后根据 <code>handlerName</code> 从之前注册过的 <code>messageHandlers</code> 里面取出对应的 <code>handler</code>（block），再调用这个 <code>handler</code>，第一个参数就是 <code>data</code>，第二个参数是根据 <code>callbackId</code> 创建的 <code>responseCallback</code>（block），然后原生就可以在 <code>handler</code>（block） 中处理接收到的 data 以及回调 JS。</p>
<p><strong>（5）原生回调 JS</strong><br>那么这个回调 JS 的 <code>responseCallback</code>（block） 是怎么处理的呢？当这个 <code>responseCallback</code> 被回调时，在这个 <code>callback</code> 中会创建一个 <code>message</code> （NSDictionary）对象，其中包含两个字段，一个是 <code>callbackId</code>，另一个传进 <code>responseCallback</code> 的参数 <code>data</code>，然后再将这个 <code>message</code> （NSDictionary）对象转成 JSON String，最后调用 JS 中的 <code>_handleMessageFromObjC(messageJSON)</code>方法，同时将 JSON String 形式的 <code>message</code> 作为参数传给 JS，接下来 JS 就会通过 <code>message</code> 中的 <code>callbackId</code> 找出之前保存的 <code>responseCallback</code>，并把 <code>message</code> 中的 <code>data</code> 作为参数，回调这个 <code>responseCallback</code>。至此，整个 JS 调原生的流程就跑通了。</p>
<h4 id="2-3-原生调用-JS"><a href="#2-3-原生调用-JS" class="headerlink" title="2.3 原生调用 JS"></a>2.3 原生调用 JS</h4><p><img src="https://coding.net/u/ShannonChen/p/Static-Resources/git/raw/master/%25E6%25B5%2581%25E7%25A8%258B%25E5%259B%25BE_02.png" alt="原生调用 JS.png"></p>
<p>原生调用 JS 其实本身可以直接通过 web view 来执行 JavaScript 脚本来实现的，但是 <code>WebViewJavascriptBridge</code> 提供了一个更贴近原生的方式。一是调用更规范，二是使用 block 的方式将调用与 JS 回调归并到一起了，代码逻辑更连贯。</p>
<p>与上面的 JS 调用原生恰好相反，原生调用 JS 时调用过程很简单，但是回调过程相对比较复杂。简单来看，如上图所示，原生调用 JS 也可以分成以下几步：</p>
<ul>
<li>原生通过调用 <code>callHandler()</code> 方法，发消息给 JS</li>
<li>在原生中将参数和回调包装成一个 message</li>
<li>原生直接调用 JS 函数将 message 传给 JS</li>
<li>JS 回调原生</li>
</ul>
<p><strong>（1）原生通过调用 <code>callHandler()</code> 方法，发消息给 JS</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self.bridge callHandler:@&quot;share&quot; data:nil responseCallback:^(id responseData) &#123;</span><br><span class="line">        NSLog(&quot;收到来自 JS 的回调&quot;);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p>
<p><strong>（2）在原生中将参数和回调包装成一个 message</strong><br>跟 JS 调用原生类似，原生调用 JS 时，也是将要调用的 <code>handlerName</code>、要传给 JS 的数据 <code>data</code> 以及 JS 回调原生的 <code>responseCallback</code> 对应的 id 包装成一个 <code>message</code>（NSDictionary），然后将这个 <code>message</code> 对象转成 JSON String。接着再调用 JS 的  <code>WebViewJavascriptBridge._handleMessageFromObjC(messageJSON)</code> 方法，把 JSON String 传给 JS。</p>
<p>同样值得注意的是，那个用于处理 JS 回调的 <code>responseCallback</code> 是一个 block，也是不能直接传给 JS 的，所以这里只传了其对应的 id，而 <code>responseCallback</code>（block） 本身会被存到一个全局的 <code>responseCallbacks</code> 字典里面去，key 值就是 <code>responseCallback</code> 对应的 id。JS 回调原生时，就会根据 id 从 <code>responseCallbacks</code> 字典中去取对应的 block。</p>
<p><strong>（3）原生直接调用 JS 函数将 message 传给 JS</strong><br>JS 拿到转为 JSON string 形式的 message 之后，先将其解析成 JS 对象，然后再取出 <code>data</code>、 <code>callbackId</code> 和 <code>handlerName</code>，最后根据 <code>handlerName</code> 从之前注册过的 <code>messageHandlers</code> 里面取出对应的 <code>handler</code> 函数，再执行这个 <code>handler</code> 函数，第一个参数就是 <code>data</code>，第二个参数是根据 <code>callbackId</code> 创建的 <code>responseCallback</code>（function），然后 JS 就可以在 <code>handler</code> 函数中处理接收到的 <code>data</code> 以及回调原生。</p>
<p><strong>（4）JS 回调原生</strong><br>那么这个回调原生的 <code>responseCallback</code>（function） 是怎么处理的呢？与前面 JS 调原生时原生回调 JS 的处理不太一样，因为 JS 调原生是不能直接调的，所以当这个 <code>responseCallback</code>（function）  被回调时，在这个 function 中会用“发消息”的方式，直接走前面所提到的 JS 调原生的流程。<br>  但这其中有两点与 JS 直接调原生不太一样的地方，一是 message 的内容，二是原生对这个 message 的处理：</p>
<ul>
<li>JS 在回调原生时，会把 <code>handlerName</code>，<code>responseId</code>（也就是原生调 JS 时传过来的 <code>callbackId</code>） 和 <code>responseData</code> 包装成一个 <code>message</code> 对象。<strong>与 JS 直接调原生不同的是，这里的 <code>message</code> 对象没有 JS 回调函数的 <code>callbackId</code>，因为这里不需要原生再次回调 JS 了</strong>。但是多了一个 <code>responseId</code>，这是因为原生执行 JS 的回调时，会根据这个 <code>responseId</code> 从 <code>responseCallbacks</code>（NSDictionary） 中去取对应的 <code>block</code>。</li>
<li>当原生收到并解析 JS 回调的消息后，会直接根据 message 中的 <code>responseId</code> 找出之前保存的 <code>responseCallback</code>（block），并把 message 中的 <code>responseData</code> 作为参数，然后再回调这个 <code>responseCallback</code>。**与 JS 直接调原生不同的是，这个 <code>responseCallback</code> 只有一个参数 <code>data</code>，没有用于再次回调 JS 的 block 了。<br>至此，整个原生调 JS 的流程就圆满结束了。</li>
</ul>
<h4 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h4><p>一句话来概括的话，那就是——<code>WebViewJavascriptBridge</code> 以下面两个方法为桥梁（以 <code>UIWebView</code> 为例）：</p>
<ul>
<li>原生调 JS：<code>-stringByEvaluatingJavaScriptFromString:</code> </li>
<li>JS 调原生：<code>- webView:shouldStartLoadWithRequest:navigationType:</code> </li>
</ul>
<p>在 JS 和原生两边封装了一套『方法调用』转『消息发送』的机制，各自维护了一套注册的方法列表、回调函数列表，优雅地解决了回调的问题。（注：不要把这里的消息发送和 Objective-C 运行时的消息发送混淆了）</p>
<h3 id="三、源码解读"><a href="#三、源码解读" class="headerlink" title="三、源码解读"></a>三、源码解读</h3><blockquote>
<p>这里只针对核心逻辑进行分析，详见 <a href="https://github.com/ShannonChenCHN/iOSLevelingUp/tree/master/ReadingSourceCode/WebViewJavascriptBridgeNotes/WebViewJavascriptBridge-6.0.2" target="_blank" rel="noopener">带有注释的源码</a>。</p>
</blockquote>
<p>对照上面的流程我们来看看 <code>WebViewJavascriptBridge</code> 的源码具体是如何实现的。</p>
<h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.  初始化"></a>1.  初始化</h4><p>（1） Objective-C 中的初始化<br>首先从创建  <code>UIWebView</code> 和 <code>WebViewJavascriptBridge</code> 对象开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController</span><br><span class="line">// 创建 web view</span><br><span class="line">UIWebView *webView = [[UIWebView alloc] initWithFrame:self.view.bounds];</span><br><span class="line">webView.autoresizingMask = UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleWidth;</span><br><span class="line">[self.view addSubview:webView];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 创建 WebViewJavascriptBridge 对象</span><br><span class="line">self.bridge = [WebViewJavascriptBridge bridgeForWebView:webView];</span><br><span class="line">...</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p><code>WebViewJavascriptBridge</code> 的 <code>+ bridgeForWebView:</code> 方法在内部针对不同的 web view 做了不同的逻辑处理，由于我这里使用的是 <code>UIWebView</code>，所以这里最终会调用 <code>-_platformSpecificSetup:</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@implementation WebViewJavascriptBridgeBase</span><br><span class="line">...</span><br><span class="line">// 创建 Bridge</span><br><span class="line">+ (instancetype)bridgeForWebView:(id)webView &#123;</span><br><span class="line">    return [self bridge:webView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)bridge:(id)webView &#123;</span><br><span class="line">    </span><br><span class="line">    // 为 WKWebView 初始化</span><br><span class="line">#if defined supportsWKWebView</span><br><span class="line">    if ([webView isKindOfClass:[WKWebView class]]) &#123;</span><br><span class="line">        return (WebViewJavascriptBridge*) [WKWebViewJavascriptBridge bridgeForWebView:webView];</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    // 为  UIWebView（iOS） 或者 WebView（OSX） 初始化</span><br><span class="line">    if ([webView isKindOfClass:[WVJB_WEBVIEW_TYPE class]]) &#123;</span><br><span class="line">        WebViewJavascriptBridge* bridge = [[self alloc] init]; // 注意：这里用的不是 WebViewJavascriptBridge 而是 self</span><br><span class="line">        [bridge _platformSpecificSetup:webView];  // 针对不同平台进行初始设置：保存 webView，并设置 webView 的 delegate，创建 WebViewJavascriptBridgeBase 对象，并设置 WebViewJavascriptBridgeBase 的 delegate</span><br><span class="line">        return bridge;</span><br><span class="line">    &#125;</span><br><span class="line">    [NSException raise:@&quot;BadWebViewType&quot; format:@&quot;Unknown web view type.&quot;];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>然后在 <code>-_platformSpecificSetup:</code> 方法中会设置 web view 的代理为 <code>self</code>，并且创建了一个 <code>WebViewJavascriptBridgeBase</code> 对象，同时设置这个对象的代理为 <code>self</code>。其目的是为了：<br>① 监听 <code>UIWebView</code> 的代理方法回调；<br>② 把桥接的核心逻辑交给 <code>WebViewJavascriptBridgeBase</code> 去处理；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@implementation WebViewJavascriptBridge</span><br><span class="line">...</span><br><span class="line">- (void) _platformSpecificSetup:(WVJB_WEBVIEW_TYPE*)webView &#123;</span><br><span class="line">    _webView = webView;</span><br><span class="line">    _webView.delegate = self;</span><br><span class="line">    _base = [[WebViewJavascriptBridgeBase alloc] init];</span><br><span class="line">    _base.delegate = self;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p><code>WebViewJavascriptBridgeBase</code> 在初始化时，会为原生端初始化几个后面用于处理消息的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@implementation WebViewJavascriptBridgeBase</span><br><span class="line">...</span><br><span class="line">- (id)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        self.messageHandlers = [NSMutableDictionary dictionary];    // 用来保存 handler （一个 `WVJBHandler` 类型的 block）的字典</span><br><span class="line">        self.startupMessageQueue = [NSMutableArray array];          // 用来保存初始消息的数组</span><br><span class="line">        self.responseCallbacks = [NSMutableDictionary dictionary];  // 用来保存回调 JS 的 block 的字典（原生调 JS 后，JS 再回调原生时会用到）</span><br><span class="line">        _uniqueId = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>（2）通过调用 <code>-registerHandler:handler:</code> 方法，注册 handler 供 JS 调用，这个方法会把要注册的 handler（block）保存到 <code>WebViewJavascriptBridgeBase</code>对象的 <code>messageHandlers</code>（NSDictionary）属性中去，当 JS 回调后，就会根据 handlerName 从这个变量中去取对应的 handler：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@implementation WebViewJavascriptBridge</span><br><span class="line">...</span><br><span class="line">- (void)registerHandler:(NSString *)handlerName handler:(WVJBHandler)handler &#123;</span><br><span class="line">    _base.messageHandlers[handlerName] = [handler copy]; // 保存 handler</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>（3） Objective-C 中通过调用 <code>UIWebView</code> 的 <code>-loadRequest:</code> 方法加载 URL 后，网页一加载就会执行 web 页中的 bridge 初始化代码，也就是调用 <code>setupWebViewJavascriptBridge(bridge)</code> 函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/JavaScript&quot;&gt;</span><br><span class="line">// 初始化 WebViewJavascriptBridge</span><br><span class="line">function setupWebViewJavascriptBridge(callback) &#123;</span><br><span class="line">                </span><br><span class="line">    // 只在第一次调用时不执行，为了防止重复加载 WebViewJavascriptBridge_JS.m</span><br><span class="line">    if (window.WebViewJavascriptBridge) &#123;</span><br><span class="line">        return callback(WebViewJavascriptBridge);</span><br><span class="line">    &#125;</span><br><span class="line">                </span><br><span class="line">    // 保存 callback</span><br><span class="line">    if (window.WVJBCallbacks) &#123;</span><br><span class="line">        return window.WVJBCallbacks.push(callback);</span><br><span class="line">    &#125;</span><br><span class="line">    window.WVJBCallbacks = [callback];</span><br><span class="line">                </span><br><span class="line">    // 开启一个 iframe，加载这段 URL &apos;wvjbscheme://__BRIDGE_LOADED__&apos;</span><br><span class="line">    // 其目的是为了触发 WebViewJavascriptBridge_JS.m 文件内容的加载</span><br><span class="line">    var WVJBIframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">    WVJBIframe.style.display = &apos;none&apos;;</span><br><span class="line">    WVJBIframe.src = &apos;wvjbscheme://__BRIDGE_LOADED__&apos;;</span><br><span class="line">    document.documentElement.appendChild(WVJBIframe);</span><br><span class="line">    setTimeout(</span><br><span class="line">        function() &#123;</span><br><span class="line">             document.documentElement.removeChild(WVJBIframe);</span><br><span class="line">        &#125;, 0);</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">    // 显式调用 setupWebViewJavascriptBridge 方法，触发 WebViewJavascriptBridge 的初始化</span><br><span class="line">    setupWebViewJavascriptBridge(</span><br><span class="line">            </span><br><span class="line">    function(bridge) &#123;</span><br><span class="line">     /* Initialize your app here */</span><br><span class="line">                                           </span><br><span class="line">        bridge.registerHandler(&quot;share&quot;, function(data, responseCallback) &#123;</span><br><span class="line">                                        var params = &#123;&apos;title&apos;:&apos;测试分享的标题&apos;,&apos;content&apos;:&apos;测试分享的内容&apos;,&apos;url&apos;:&apos;http://www.baidu.com&apos;&#125;;</span><br><span class="line">                                                                responseCallback(params);</span><br><span class="line">                                                                &#125;);</span><br><span class="line">                                         &#125;</span><br><span class="line">            </span><br><span class="line">            );</span><br><span class="line">...</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>这里调用 <code>setupWebViewJavascriptBridge()</code> 函数时，传入的参数是一个带有自定义初始化逻辑（比如 JS 中注册 handler）的 <code>function</code>，相当于原生中的 block。<br>这个 <code>function</code> <code>setupWebViewJavascriptBridge()</code> 函数主要做了两件事情：</p>
<ul>
<li>将传进来的参数保存到 <code>window.WVJBCallbacks</code> 中，等到后面 JS 端的 bridge 初始化成功后，再取出来调用</li>
<li>通过添加一个 iframe 加载初始化链接 <code>https://__bridge_loaded__</code>，调起原生，然后再移除这个 iframe</li>
</ul>
<p>（5） 原生中的 <code>WebViewJavascriptBridge</code> 对象中代理方法会拦截到 <code>https://__bridge_loaded__</code> 的加载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@implementation WebViewJavascriptBridge</span><br><span class="line">...</span><br><span class="line">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123;</span><br><span class="line">    if (webView != _webView) &#123; return YES; &#125;</span><br><span class="line">    </span><br><span class="line">    NSURL *url = [request URL];</span><br><span class="line">    __strong WVJB_WEBVIEW_DELEGATE_TYPE* strongDelegate = _webViewDelegate;</span><br><span class="line">    </span><br><span class="line">    if ([_base isWebViewJavascriptBridgeURL:url]) &#123; // 是不是 Bridge 的 URL</span><br><span class="line">        </span><br><span class="line">        if ([_base isBridgeLoadedURL:url]) &#123;  // 是不是第一次加载时的 URL</span><br><span class="line">            </span><br><span class="line">            [_base injectJavascriptFile];    // 注入 WebViewJavascriptBridge_JS 文件中的 JavaScript</span><br><span class="line">            </span><br><span class="line">        &#125; else if ([_base isQueueMessageURL:url]) &#123;  // 是不是发送消息给 Native 的 URL</span><br><span class="line">            </span><br><span class="line">            NSString *messageQueueString = [self _evaluateJavascript:[_base webViewJavascriptFetchQueyCommand]];</span><br><span class="line">            [_base flushMessageQueue:messageQueueString];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            [_base logUnkownMessage:url];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125; else if (strongDelegate &amp;&amp; [strongDelegate respondsToSelector:@selector(webView:shouldStartLoadWithRequest:navigationType:)]) &#123;</span><br><span class="line">        return [strongDelegate webView:webView shouldStartLoadWithRequest:request navigationType:navigationType];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>在 <code>-webView:shouldStartLoadWithRequest:navigationType:</code>方法中，首先会根据 URL 的 scheme 来判断这个 URL 是不是跟 bridge 相关的 URL，然后再根据 URL 的 host 来判断是用来初始化 JS 中的 bridge 的（<code>__bridge_loaded__</code>），还是用来发消息给原生的（<code>__wvjb_queue_message__</code>）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">#define kOldProtocolScheme @&quot;wvjbscheme&quot;</span><br><span class="line">#define kNewProtocolScheme @&quot;https&quot;</span><br><span class="line">#define kQueueHasMessage   @&quot;__wvjb_queue_message__&quot;</span><br><span class="line">#define kBridgeLoaded      @&quot;__bridge_loaded__&quot;</span><br><span class="line"></span><br><span class="line">@implementation WebViewJavascriptBridgeBase</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/// 判断 URL 是不是跟 bridge 相关的</span><br><span class="line">- (BOOL)isWebViewJavascriptBridgeURL:(NSURL*)url &#123;</span><br><span class="line">    if (![self isSchemeMatch:url]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return [self isBridgeLoadedURL:url] || [self isQueueMessageURL:url];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// scheme 是不是 wvjbscheme 或者 https</span><br><span class="line">- (BOOL)isSchemeMatch:(NSURL*)url &#123;</span><br><span class="line">    NSString* scheme = url.scheme.lowercaseString;</span><br><span class="line">    </span><br><span class="line">    return [scheme isEqualToString:kNewProtocolScheme] || [scheme isEqualToString:kOldProtocolScheme];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// host 是不是 __wvjb_queue_message__，并且 scheme 也匹配</span><br><span class="line">/// 用来判断是不是发送消息给 Native 的 URL</span><br><span class="line">- (BOOL)isQueueMessageURL:(NSURL*)url &#123;</span><br><span class="line">    NSString* host = url.host.lowercaseString;</span><br><span class="line">    return [self isSchemeMatch:url] &amp;&amp; [host isEqualToString:kQueueHasMessage];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// host 是不是 __bridge_loaded__，并且 scheme 也匹配</span><br><span class="line">/// 用来判断是不是第一次加载时的 URL</span><br><span class="line">- (BOOL)isBridgeLoadedURL:(NSURL*)url &#123;</span><br><span class="line">    NSString* host = url.host.lowercaseString;</span><br><span class="line">    return [self isSchemeMatch:url] &amp;&amp; [host isEqualToString:kBridgeLoaded];</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>此时的 URL 是 <code>https://__bridge_loaded__</code>，所以肯定是走 <code>[_base injectJavascriptFile];</code> 的逻辑，这个方法主要是加载  WebViewJavascriptBridge_js.m 文件中的 JS：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/// 注入 JS ，进行一些初始化操作</span><br><span class="line">- (void)injectJavascriptFile &#123;</span><br><span class="line">    NSString *js = WebViewJavascriptBridge_js(); // MARK: 为什么用这种方式加载，而不是写成一个 .js 文件再读取呢？</span><br><span class="line">    [self _evaluateJavascript:js];  // 执行 WebViewJavascriptBridge_JS 文件中的 JavaScript</span><br><span class="line">    </span><br><span class="line">    // 如果队列中有未发送的消息，马上发给 JS</span><br><span class="line">    if (self.startupMessageQueue) &#123;</span><br><span class="line">        NSArray* queue = self.startupMessageQueue;</span><br><span class="line">        self.startupMessageQueue = nil;</span><br><span class="line">        for (id queuedMessage in queue) &#123;</span><br><span class="line">            [self _dispatchMessage:queuedMessage];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（6）在 web view 中执行本地 WebViewJavascriptBridge_JS.m 文件中的代码后，首先会初始化 <code>window.WebViewJavascriptBridge</code> 对象，并定义几个方法和全局变量：</p>
<ul>
<li>在 JS 中初始化 <code>WebViewJavascriptBridge</code> 对象，并设置成 <code>window</code> 的一个属性</li>
<li>定义几个全局变量<ul>
<li><code>sendMessageQueue</code>：保存待发送消息的数组</li>
<li><code>messageHandlers</code>：保存注册过的 handler 的对象</li>
<li><code>responseCallbacks</code>：保存 callback 的对象</li>
<li><code>uniqueId</code>：保存 callback 时对应的 id</li>
</ul>
</li>
<li>定义以下几个方法<ul>
<li><code>registerHandler(handlerName, handler)</code>：注册 hander</li>
<li><code>callHandler(handlerName, data, responseCallback)</code>：调用 handler</li>
<li><code>_fetchQueue()</code>：获取待发送消息</li>
<li><code>disableJavscriptAlertBoxSafetyTimeout()</code>：让OC可以关闭回调超时</li>
<li><code>_handleMessageFromObjC(messageJSON)</code>：调用 <code>_dispatchMessageFromObjC</code>处理来自 Objective-C 的消息</li>
</ul>
</li>
<li>定义两个函数，给上面几个方法调用 <ul>
<li><code>_doSend(message, responseCallback)</code>：将要发送的消息保存到 sendMessageQueue 中，同时加载 URL 调起原生</li>
<li><code>_dispatchMessageFromObjC(messageJSON)</code>：处理 Objective-C 中发来的消息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">WebViewJavascriptBridge_JS.m</span><br><span class="line">...</span><br><span class="line">// 初始化 WebViewJavascriptBridge 对象</span><br><span class="line">	window.WebViewJavascriptBridge = &#123;</span><br><span class="line">		registerHandler: registerHandler,</span><br><span class="line">		callHandler: callHandler,</span><br><span class="line">		disableJavscriptAlertBoxSafetyTimeout: disableJavscriptAlertBoxSafetyTimeout,</span><br><span class="line">		_fetchQueue: _fetchQueue,</span><br><span class="line">		_handleMessageFromObjC: _handleMessageFromObjC</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	var messagingIframe;</span><br><span class="line">	var sendMessageQueue = [];  // 保存消息的数组</span><br><span class="line">	var messageHandlers = &#123;&#125;;   // 保存 handler 的对象</span><br><span class="line">	</span><br><span class="line">	var CUSTOM_PROTOCOL_SCHEME = &apos;https&apos;;</span><br><span class="line">	var QUEUE_HAS_MESSAGE = &apos;__wvjb_queue_message__&apos;;  // 发送消息的 URL scheme</span><br><span class="line">	</span><br><span class="line">	var responseCallbacks = &#123;&#125;;  // 回调函数</span><br><span class="line">	var uniqueId = 1;            // 保存 callback 的唯一标识</span><br><span class="line">	var dispatchMessagesWithTimeoutSafety = true;</span><br><span class="line"></span><br><span class="line">    // 注册 handler 的方法</span><br><span class="line">	function registerHandler(handlerName, handler) &#123;</span><br><span class="line">		messageHandlers[handlerName] = handler;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    // 调用 Native handler 的方法</span><br><span class="line">	function callHandler(handlerName, data, responseCallback) &#123;</span><br><span class="line">        // 如果只有两个参数，并且第二个参数是 函数</span><br><span class="line">		if (arguments.length == 2 &amp;&amp; typeof data == &apos;function&apos;) &#123;</span><br><span class="line">			responseCallback = data;</span><br><span class="line">			data = null;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        // 发送消息给 Native</span><br><span class="line">		_doSend(&#123; handlerName:handlerName, data:data &#125;, responseCallback);</span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line">	function disableJavscriptAlertBoxSafetyTimeout() &#123;</span><br><span class="line">		dispatchMessagesWithTimeoutSafety = false;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    // 发送消息给 Native</span><br><span class="line">    // 一个消息包含一个 handler 和 data，以及一个 callbackId</span><br><span class="line">    // 因为 JavaScript 中的 callback 是函数，不能直接传给 Objective-C，</span><br><span class="line">	function _doSend(message, responseCallback) &#123;</span><br><span class="line">		</span><br><span class="line">        if (responseCallback) &#123;</span><br><span class="line">			var callbackId = &apos;cb_&apos;+(uniqueId++)+&apos;_&apos;+new Date().getTime();  // callbackId 的格式：cb + 唯一标识 id + 时间戳</span><br><span class="line">            </span><br><span class="line">			responseCallbacks[callbackId] = responseCallback;  // 保存 responseCallback 到 responseCallbacks 中去</span><br><span class="line">            </span><br><span class="line">			message[&apos;callbackId&apos;] = callbackId;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		sendMessageQueue.push(message); // 将要发送的消息保存到 sendMessageQueue 中</span><br><span class="line">        </span><br><span class="line">		messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + &apos;://&apos; + QUEUE_HAS_MESSAGE;  // https://__wvjb_queue_message__</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    // 从消息队列中拉取消息</span><br><span class="line">	function _fetchQueue() &#123;</span><br><span class="line">		var messageQueueString = JSON.stringify(sendMessageQueue);</span><br><span class="line">    </span><br><span class="line">		sendMessageQueue = [];</span><br><span class="line">		return messageQueueString;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    // 处理 Objective-C 中发来的消息</span><br><span class="line">	function _dispatchMessageFromObjC(messageJSON) &#123;</span><br><span class="line">        </span><br><span class="line">		if (dispatchMessagesWithTimeoutSafety) &#123;</span><br><span class="line">			setTimeout(_doDispatchMessageFromObjC);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			 _doDispatchMessageFromObjC();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        // 处理 Objective-C 中发来的消息</span><br><span class="line">		function _doDispatchMessageFromObjC() &#123;</span><br><span class="line">            </span><br><span class="line">			var message = JSON.parse(messageJSON);  // JSON 解析</span><br><span class="line">			var messageHandler;</span><br><span class="line">			var responseCallback;</span><br><span class="line"></span><br><span class="line">			if (message.responseId) &#123;  // 执行 JavaScript 调用原生时的回调</span><br><span class="line">                </span><br><span class="line">				responseCallback = responseCallbacks[message.responseId];</span><br><span class="line">				if (!responseCallback) &#123;</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">				responseCallback(message.responseData);</span><br><span class="line">				delete responseCallbacks[message.responseId];</span><br><span class="line">                </span><br><span class="line">			&#125; else &#123;  // 原生调用 JavaScript</span><br><span class="line">                </span><br><span class="line">				if (message.callbackId) &#123;  // JavaScript 回调 Native 的 callback</span><br><span class="line">                    </span><br><span class="line">					var callbackResponseId = message.callbackId; // 取出原生传过来的 callbackId</span><br><span class="line">					responseCallback = function(responseData) &#123;</span><br><span class="line">                        // 调用 _doSend 方法发送消息给 Native</span><br><span class="line">						_doSend(&#123; handlerName:message.handlerName, responseId:callbackResponseId, responseData:responseData &#125;);</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				var handler = messageHandlers[message.handlerName]; // 根据 handlerName 取出 JavaScript 中的 handler</span><br><span class="line">				if (!handler) &#123;</span><br><span class="line">					console.log(&quot;WebViewJavascriptBridge: WARNING: no handler for message from ObjC:&quot;, message);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">                    </span><br><span class="line">					handler(message.data, responseCallback);  // 调用 JavaScript 中的 handler</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    // 处理 Objective-C 中发来的消息</span><br><span class="line">	function _handleMessageFromObjC(messageJSON) &#123;</span><br><span class="line">        _dispatchMessageFromObjC(messageJSON);</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>初始化 <code>window.WebViewJavascriptBridge</code> 对象之后，JS 端还会创建一个 <code>messagingIframe</code>，用来加载 URL 发送消息给 Native：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建 iframe，用来加载 URL 发送消息给 Native</span><br><span class="line">	messagingIframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">	messagingIframe.style.display = &apos;none&apos;;</span><br><span class="line">	messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + &apos;://&apos; + QUEUE_HAS_MESSAGE;  // https://__wvjb_queue_message__</span><br><span class="line">	document.documentElement.appendChild(messagingIframe);</span><br></pre></td></tr></table></figure>
<p>最后，执行 <code>window.WVJBCallbacks</code> 中的回调函数，也就是通过前面的 <code>setupWebViewJavascriptBridge()</code> 函数添加的用来初始化配置的 <code>callback</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(_callWVJBCallbacks, 0);</span><br><span class="line">function _callWVJBCallbacks() &#123;</span><br><span class="line">	var callbacks = window.WVJBCallbacks;</span><br><span class="line">	delete window.WVJBCallbacks;</span><br><span class="line">	for (var i=0; i&lt;callbacks.length; i++) &#123;</span><br><span class="line">		callbacks[i](WebViewJavascriptBridge);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，整个初始化的过程就结束了，Objective-C 端和 JS 端各自有一个 bridge 环境，可以收发“消息”，处理回调。</p>
<h4 id="2-JS-调用原生"><a href="#2-JS-调用原生" class="headerlink" title="2. JS 调用原生"></a>2. JS 调用原生</h4><p>（1）JS 是以发消息的形式调用原生，发消息的过程包括三步：</p>
<ul>
<li>JS 中调用 <code>callHandler()</code>方法，传入数据和回调函数。</li>
<li>紧接着为每个 <code>responseCallback</code> 生成一个对应的 <code>callbackId</code>，然后再将 <code>handlerName</code>、参数 <code>data</code> 和<code>callbackId</code>  包装成一个 message 对象，存到全局数组 <code>sendMessageQueue</code> 中。同时把 <code>responseCallback</code> 也保存到  <code>responseCallbacks</code> 对象中去，等原生回调时再取。</li>
<li>最后 JS 中加载发送消息的链接 <code>https://__wvjb_queue_message__</code>，通知原生到它那边去取 message。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function callHandler(handlerName, data, responseCallback) &#123;</span><br><span class="line">        // 如果只有两个参数，并且第二个参数是 函数</span><br><span class="line">		if (arguments.length == 2 &amp;&amp; typeof data == &apos;function&apos;) &#123;</span><br><span class="line">			responseCallback = data;</span><br><span class="line">			data = null;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        // 发送消息给 Native</span><br><span class="line">		_doSend(&#123; handlerName:handlerName, data:data &#125;, responseCallback);</span><br><span class="line">	&#125;</span><br><span class="line">// 发送消息给 Native</span><br><span class="line">    // 一个消息包含一个 handler 和 data，以及一个 callbackId</span><br><span class="line">    // 因为 JavaScript 中的 callback 是函数，不能直接传给 Objective-C，</span><br><span class="line">	function _doSend(message, responseCallback) &#123;</span><br><span class="line">		</span><br><span class="line">        if (responseCallback) &#123;</span><br><span class="line">			var callbackId = &apos;cb_&apos;+(uniqueId++)+&apos;_&apos;+new Date().getTime();  // callbackId 的格式：cb + 唯一标识 id + 时间戳</span><br><span class="line">            </span><br><span class="line">			responseCallbacks[callbackId] = responseCallback;  // 保存 responseCallback 到 responseCallbacks 中去</span><br><span class="line">            </span><br><span class="line">			message[&apos;callbackId&apos;] = callbackId;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		sendMessageQueue.push(message); // 将要发送的消息保存到 sendMessageQueue 中</span><br><span class="line">        </span><br><span class="line">		messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + &apos;://&apos; + QUEUE_HAS_MESSAGE;  // https://__wvjb_queue_message__</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>（2）原生在 <code>-webView: shouldStartLoadWithRequest: navigationType:</code> 方法中拦截到 <code>https://__wvjb_queue_message__</code> 的加载，然后执行 JS 脚本<code>WebViewJavascriptBridge._fetchQueue();</code> 从 JS 拉取 message ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@ implementation WebViewJavascriptBridge</span><br><span class="line">...</span><br><span class="line">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123;</span><br><span class="line">...</span><br><span class="line">NSString *messageQueueString = [self _evaluateJavascript:[_base webViewJavascriptFetchQueyCommand]];</span><br><span class="line">            [_base flushMessageQueue:messageQueueString];</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (NSString*) _evaluateJavascript:(NSString*)javascriptCommand &#123;</span><br><span class="line">    return [_webView stringByEvaluatingJavaScriptFromString:javascriptCommand];</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@implementation WebViewJavascriptBridgeBase</span><br><span class="line">...</span><br><span class="line">/// 从消息队列中拉取消息</span><br><span class="line">- (NSString *)webViewJavascriptFetchQueyCommand &#123;</span><br><span class="line">    return @&quot;WebViewJavascriptBridge._fetchQueue();&quot;;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>原生拿到转为 JSON string 的 message 之后，先将其解析成原生的字典，然后再取出 <code>data</code>、 <code>callbackId</code> 和 <code>handlerName</code>，最后根据 <code>handlerName</code> 从之前注册过的 <code>messageHandlers</code> 里面取出对应的 <code>handler</code>（block），接着再调用这个 <code>handler</code>，第一个参数就是 <code>data</code>，第二个参数是根据 <code>callbackId</code> 创建的 <code>responseCallback</code>（block），然后原生就可以在 <code>handler</code>（block） 中处理接收到的 data 以及回调 JS：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">@implementation WebViewJavascriptBridgeBase</span><br><span class="line">...</span><br><span class="line">- (void)flushMessageQueue:(NSString *)messageQueueString&#123;</span><br><span class="line"></span><br><span class="line">    // 解析消息队列中的消息</span><br><span class="line">    id messages = [self _deserializeMessageJSON:messageQueueString];</span><br><span class="line">    </span><br><span class="line">    for (WVJBMessage* message in messages) &#123;</span><br><span class="line">        if (![message isKindOfClass:[WVJBMessage class]]) &#123;</span><br><span class="line">            NSLog(@&quot;WebViewJavascriptBridge: WARNING: Invalid %@ received: %@&quot;, [message class], message);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        [self _log:@&quot;RCVD&quot; json:message];</span><br><span class="line">        </span><br><span class="line">        NSString* responseId = message[@&quot;responseId&quot;];</span><br><span class="line">        if (responseId) &#123;   // JS 回调原生的处理</span><br><span class="line">            WVJBResponseCallback responseCallback = _responseCallbacks[responseId];</span><br><span class="line">            responseCallback(message[@&quot;responseData&quot;]);</span><br><span class="line">            [self.responseCallbacks removeObjectForKey:responseId];</span><br><span class="line">            </span><br><span class="line">        &#125; else &#123;  // JS 直接调原生的处理</span><br><span class="line">            </span><br><span class="line">            // 1. JavaScript 中 callback 的转换</span><br><span class="line">            WVJBResponseCallback responseCallback = NULL;</span><br><span class="line">            NSString* callbackId = message[@&quot;callbackId&quot;];  // 取出 JavaScript 中传过来的 callbackId</span><br><span class="line">            </span><br><span class="line">            if (callbackId) &#123;  // 有 JavaScript 回调，将 callback 转换为 block</span><br><span class="line">                responseCallback = ^(id responseData) &#123;</span><br><span class="line">                    if (responseData == nil) &#123;</span><br><span class="line">                        responseData = [NSNull null];</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    WVJBMessage* msg = @&#123; @&quot;responseId&quot;:callbackId, @&quot;responseData&quot;:responseData &#125;;</span><br><span class="line">                    // 回调 JavaScript</span><br><span class="line">                    [self _queueMessage:msg];</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                responseCallback = ^(id ignoreResponseData) &#123;</span><br><span class="line">                    // Do nothing</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 2. 根据 handlerName 取出对应的 handler</span><br><span class="line">            WVJBHandler handler = self.messageHandlers[message[@&quot;handlerName&quot;]];</span><br><span class="line">            </span><br><span class="line">            if (!handler) &#123;</span><br><span class="line">                NSLog(@&quot;WVJBNoHandlerException, No handler for message from JS: %@&quot;, message);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 3. 执行 handler</span><br><span class="line">            handler(message[@&quot;data&quot;], responseCallback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>（3）原生回调 JS<br>当这个 <code>responseCallback</code> 被回调时，在这个 <code>callback</code>（block） 中会创建一个 <code>message</code> （NSDictionary）对象，其中包含两个字段，一个是<code>callbackId</code>，另一个是传进 <code>responseCallback</code> 的参数 <code>data</code>，然后再将这个 <code>message</code> （NSDictionary）对象转成 JSON String，最后调用 JS 中的 <code>_handleMessageFromObjC(messageJSON)</code> 方法，同时将 JSON String 形式的 <code>message</code> 作为参数传给 JS：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@implementation WebViewJavascriptBridgeBase</span><br><span class="line">...</span><br><span class="line">- (void)_queueMessage:(WVJBMessage*)message &#123;</span><br><span class="line">    if (self.startupMessageQueue) &#123;</span><br><span class="line">        [self.startupMessageQueue addObject:message];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self _dispatchMessage:message];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Objective-C 发消息给 JavaScript</span><br><span class="line">- (void)_dispatchMessage:(WVJBMessage*)message &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *messageJSON = [self _serializeMessage:message pretty:NO]; // 将消息转成 JSON string</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    NSString* javascriptCommand = [NSString stringWithFormat:@&quot;WebViewJavascriptBridge._handleMessageFromObjC(&apos;%@&apos;);&quot;, messageJSON];</span><br><span class="line">    [self _evaluateJavascript:javascriptCommand];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>接下来 JS 就会根据 <code>message</code> 中的 <code>callbackId</code> 找出之前保存的 <code>responseCallback</code>，并把 <code>message</code> 中的 <code>data</code> 作为参数，回调这个 <code>responseCallback</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">WebViewJavascriptBridge_JS.m</span><br><span class="line">...</span><br><span class="line">    // 处理 Objective-C 中发来的消息</span><br><span class="line">      function _handleMessageFromObjC(messageJSON) &#123;</span><br><span class="line">          _dispatchMessageFromObjC(messageJSON);</span><br><span class="line">    &#125;</span><br><span class="line">      function _doDispatchMessageFromObjC() &#123;</span><br><span class="line">               ...</span><br><span class="line">               var message = JSON.parse(messageJSON);  // JSON 解析</span><br><span class="line">			   var messageHandler;</span><br><span class="line">			   var responseCallback;</span><br><span class="line">               if (message.callbackId) &#123;  // JavaScript 回调 Native 的 callback</span><br><span class="line">                    </span><br><span class="line">					var callbackResponseId = message.callbackId; // 取出原生传过来的 callbackId</span><br><span class="line">					responseCallback = function(responseData) &#123;</span><br><span class="line">                        // 调用 _doSend 方法发送消息给 Native</span><br><span class="line">						_doSend(&#123; handlerName:message.handlerName, responseId:callbackResponseId, responseData:responseData &#125;);</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				var handler = messageHandlers[message.handlerName]; // 根据 handlerName 取出 JavaScript 中的 handler</span><br><span class="line">				if (!handler) &#123;</span><br><span class="line">					console.log(&quot;WebViewJavascriptBridge: WARNING: no handler for message from ObjC:&quot;, message);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">                    </span><br><span class="line">					handler(message.data, responseCallback);  // 调用 JavaScript 中的 handler</span><br><span class="line">				&#125;</span><br><span class="line">              ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，整个 JS 调原生的流程就结束了。</p>
<h4 id="3-原生调用-JS"><a href="#3-原生调用-JS" class="headerlink" title="3. 原生调用 JS"></a>3. 原生调用 JS</h4><p>（1）JS 包装并发送消息给 JS<br>JS 中首先调用 <code>callHandler()</code> 方法，传入要传递的数据和回调函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@implementation WebViewJavascriptBridge</span><br><span class="line">...</span><br><span class="line">- (void)send:(id)data responseCallback:(WVJBResponseCallback)responseCallback &#123;</span><br><span class="line">    [_base sendData:data responseCallback:responseCallback handlerName:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)callHandler:(NSString *)handlerName &#123;</span><br><span class="line">    [self callHandler:handlerName data:nil responseCallback:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)callHandler:(NSString *)handlerName data:(id)data &#123;</span><br><span class="line">    [self callHandler:handlerName data:data responseCallback:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)callHandler:(NSString *)handlerName data:(id)data responseCallback:(WVJBResponseCallback)responseCallback &#123;</span><br><span class="line">    [_base sendData:data responseCallback:responseCallback handlerName:handlerName];</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>接着跟 JS 调用原生一样，原生调用 JS 时，也是将要调用的 <code>handlerName</code>、要传给 JS 的数据 data 以及 JS 回调原生的 <code>responseCallback</code> 对应的 id 包装成一个 <code>message</code>（NSDictionary），然后将这个 <code>message</code> 对象转成 JSON String。接着再调用 JS 的 <code>WebViewJavascriptBridge._handleMessageFromObjC(messageJSON)</code> 方法，把 JSON String 传给 JS：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@implementation WebViewJavascriptBridgeBase</span><br><span class="line">...</span><br><span class="line">// 原生发送消息给 JavaScript</span><br><span class="line">- (void)sendData:(id)data responseCallback:(WVJBResponseCallback)responseCallback handlerName:(NSString*)handlerName &#123;</span><br><span class="line">    NSMutableDictionary* message = [NSMutableDictionary dictionary];</span><br><span class="line">    </span><br><span class="line">    if (data) &#123;</span><br><span class="line">        message[@&quot;data&quot;] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (responseCallback) &#123;</span><br><span class="line">        NSString* callbackId = [NSString stringWithFormat:@&quot;objc_cb_%ld&quot;, ++_uniqueId];</span><br><span class="line">        self.responseCallbacks[callbackId] = [responseCallback copy];  // 保存  responseCallback</span><br><span class="line">        message[@&quot;callbackId&quot;] = callbackId;  // 将 callbackId 传给 JavaScript</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (handlerName) &#123;</span><br><span class="line">        message[@&quot;handlerName&quot;] = handlerName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self _queueMessage:message];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)_queueMessage:(WVJBMessage*)message &#123;</span><br><span class="line">    if (self.startupMessageQueue) &#123;</span><br><span class="line">        [self.startupMessageQueue addObject:message];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self _dispatchMessage:message];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 把消息传给 JS</span><br><span class="line">- (void)_dispatchMessage:(WVJBMessage*)message &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *messageJSON = [self _serializeMessage:message pretty:NO]; // 将消息转成 JSON string</span><br><span class="line">   ...</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">NSString* javascriptCommand = [NSString stringWithFormat:@&quot;WebViewJavascriptBridge._handleMessageFromObjC(&apos;%@&apos;);&quot;, messageJSON];</span><br><span class="line">[self _evaluateJavascript:javascriptCommand];</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>（2）JS 处理原生发来的消息<br><code>WebViewJavascriptBridge._handleMessageFromObjC()</code> 方法在内部调用了 <code>_dispatchMessageFromObjC()</code> 方法，先将其解析成 JS 对象，然后再取出 <code>data</code>、 <code>callbackId</code> 和 <code>handlerName</code>，最后根据 <code>handlerName</code> 从之前注册过的 <code>messageHandlers</code> 里面取出对应的 <code>handler</code> 函数，再执行这个 <code>handler</code> 函数，第一个参数就是 <code>data</code>，第二个参数是根据 <code>callbackId</code> 创建的 <code>responseCallback</code>（function），然后 JS 就可以在 <code>handler</code> 函数中处理接收到的 <code>data</code> 以及回调原生：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">WebViewJavascriptBridge_JS.m</span><br><span class="line">// 处理 Objective-C 中发来的消息</span><br><span class="line">	function _dispatchMessageFromObjC(messageJSON) &#123;</span><br><span class="line">        ...</span><br><span class="line">        // 处理 Objective-C 中发来的消息</span><br><span class="line">		function _doDispatchMessageFromObjC() &#123;</span><br><span class="line">            </span><br><span class="line">			var message = JSON.parse(messageJSON);  // JSON 解析</span><br><span class="line">			var messageHandler;</span><br><span class="line">			var responseCallback;</span><br><span class="line"></span><br><span class="line">			if (message.responseId) &#123;  // 执行 JavaScript 调用原生时的回调</span><br><span class="line">				...</span><br><span class="line">			&#125; else &#123;  // 原生调用 JavaScript</span><br><span class="line">                </span><br><span class="line">				if (message.callbackId) &#123;  // JavaScript 回调 Native 的 callback</span><br><span class="line">                    </span><br><span class="line">					var callbackResponseId = message.callbackId; // 取出原生传过来的 callbackId</span><br><span class="line">					responseCallback = function(responseData) &#123;</span><br><span class="line">                        // 调用 _doSend 方法发送消息给 Native</span><br><span class="line">						_doSend(&#123; handlerName:message.handlerName, responseId:callbackResponseId, responseData:responseData &#125;);</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				var handler = messageHandlers[message.handlerName]; // 根据 handlerName 取出 JavaScript 中的 handler</span><br><span class="line">				if (!handler) &#123;</span><br><span class="line">					console.log(&quot;WebViewJavascriptBridge: WARNING: no handler for message from ObjC:&quot;, message);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">                    </span><br><span class="line">					handler(message.data, responseCallback);  // 调用 JavaScript 中的 handler</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>（3）JS 回调原生<br>当这个 <code>responseCallback</code>（function） 被回调时，在这个 function 中会直接走前面所提到的 JS 调原生的流程——调用 <code>_doSend()</code> 函数，传入 <code>handlerName</code>、<code>callbackResponseId</code>和要传给原生的数据 <code>responseData</code>。然后 <code>_doSend()</code> 函数中会把 <code>handlerName</code>，<code>responseId</code>（也就是原生调 JS 时传过来的 <code>callbackId</code>） 和 <code>responseData</code> 包装成一个 <code>meassage</code> 对象，并保存到消息队列中去，接着再在 iframe 中加载链接 <code>https://__wvjb_queue_message__</code> 触发 <code>UIWebView</code> 代理方法的回调。</p>
<p>原生收到代理回调时，就会执行 JS 脚本 <code>WebViewJavascriptBridge._fetchQueue();</code> ，到 JS 环境中去取消息，取到消息（JSON string）后，再将其解析为 Objective-C 对象。</p>
<p>这些 JS 调原生的代码前面已经有了，就不再重复贴出来了。最后，Objective-C 中拿到解析过的 message 对象后，根据 <code>responseId</code> 取出之前存过的对应的 <code>responseCallback</code>（block）进行回调，参数就是 message 中的 <code>responseData</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/// 处理 JavaScript 消息队列中的消息，发送给 Objective-C 方</span><br><span class="line">- (void)flushMessageQueue:(NSString *)messageQueueString&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    // 解析消息队列中的消息</span><br><span class="line">    id messages = [self _deserializeMessageJSON:messageQueueString];</span><br><span class="line">    </span><br><span class="line">    for (WVJBMessage* message in messages) &#123;</span><br><span class="line">        </span><br><span class="line">        NSString* responseId = message[@&quot;responseId&quot;];</span><br><span class="line">        if (responseId) &#123;   // JS 回调原生的处理</span><br><span class="line">            WVJBResponseCallback responseCallback = _responseCallbacks[responseId];</span><br><span class="line">            responseCallback(message[@&quot;responseData&quot;]);</span><br><span class="line">            [self.responseCallbacks removeObjectForKey:responseId];</span><br><span class="line">            </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止，原生调用 JS 的逻辑就结束了。</p>
<h3 id="四、最佳实践"><a href="#四、最佳实践" class="headerlink" title="四、最佳实践"></a>四、最佳实践</h3><p>在了解了 <code>WebViewJavascriptBridge</code> 的基本使用和原理之后，我们就可以更优雅地更灵活地使用这个工具了。</p>
<p>我们平时在实际开发中，更多的还是 JS 调原生的情况，比如调用原生分享、获取地理位置信息，等等。借助 <code>WebViewJavascriptBridge</code>，我们可以直接在原生项目中注册 handler，然后在 h5 中 call handler，这样比之前 Custom URL Scheme 的形式更易于使用和维护。</p>
<p>但是，这里仍然有两个问题需要考虑一下：</p>
<ul>
<li>JS 调用原生时，每次还是需要写一长串的 <code>WebViewJavascriptBridge.callHandler(handlerName, data, callback);</code>，我们能不能做到像直接调 JS 方法那样简单直接？比如像这样，<code>share(data, callback);</code>。</li>
<li>在原生 App 中，我们一般会定义一个 <code>WebViewController</code>专门用来加载 h5，然后我们会在这个类中注册所有的 handler，一开始只有少量的几个 handler，一切 OK，但是，随着时间推移，业务不断发展，handler 会越来越多，而且有些不同的页面需要注册不同的 handler，最终会导致这个 <code>WebViewController.m</code> 文件变得越来越庞大——Massive View Controller（MVC）。所以，我们期望的是，要处理的 handler 应该分成两类，一类 handler 是通用的，大部分页面都需要支持，比如，调用原生的分享，而另一部分 handler 就是各个页面自己特有的逻辑，比如调用原生的支付。</li>
</ul>
<h4 id="1-先来看看第一个问题，如何实现以下形式的转换："><a href="#1-先来看看第一个问题，如何实现以下形式的转换：" class="headerlink" title="1. 先来看看第一个问题，如何实现以下形式的转换："></a>1. 先来看看第一个问题，如何实现以下形式的转换：</h4><p><code>WebViewJavascriptBridge.callHandler(&#39;share&#39;, data, callback);</code><br>===&gt; <code>share(data, callback);</code></p>
<p>不论怎样，因为 <code>WebViewJavascriptBridge.callHandler()</code> 方法是必须要调用的，所以我们能想到的是，在别的方法内部调用这个方法。要想通过调用 <code>share</code> 方法来实现这个目标，那就得先定义一个对象来保存这个方法。<br>因此，我们可以定义一个全局对象 <code>MyApp</code>，然后给 <code>MyApp</code> 对象定义一个方法 <code>share()</code>，然后再在其内部调用 <code>WebViewJavascriptBridge.callHandler()</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var handlerNames = new Array(&quot;share&quot;, &quot;requestLocation&quot;);</span><br><span class="line"></span><br><span class="line">for (var i in handlerNames) &#123;</span><br><span class="line">    var handlerName = handlerNames[i];</span><br><span class="line"></span><br><span class="line">    MyApp[handlerName] = function(tempHandlerName) &#123;</span><br><span class="line">        return function(data, callback) &#123;</span><br><span class="line"></span><br><span class="line">            if (typeof data == &quot;function&quot;) &#123; // 意味着没有参数 data，只有一个参数 callback</span><br><span class="line"></span><br><span class="line">                bridge.callHandler(tempHandlerName, null, data);</span><br><span class="line"></span><br><span class="line">            &#125; else if (callback == null) &#123; // 第二个参数 callback 为 null 或者只有第一个参数 data</span><br><span class="line"></span><br><span class="line">                bridge.callHandler(tempHandlerName, data);</span><br><span class="line"></span><br><span class="line">            &#125; else &#123; // 两个参数都有</span><br><span class="line"></span><br><span class="line">                bridge.callHandler(tempHandlerName, data, callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(handlerName);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有了上面的“转换”后，我们在 JS 中就可以以下几种形式调用 handler 了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyApp.functionName(data, callback);     // 有参数，有回调</span><br><span class="line">MyApp.functionName(data);               // 有参数，没有回调</span><br><span class="line">MyApp.functionName(callback);           // 没有参数，有回调</span><br><span class="line">MyApp.functionName();                   // 没有参数，也没有回调</span><br></pre></td></tr></table></figure></p>
<p>比如要调用分享接口，直接这样调用就行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyApp.share(&#123;</span><br><span class="line">  title: &apos;标题&apos;,</span><br><span class="line">  subtitle: &apos;副标题&apos;,</span><br><span class="line">  image: &apos;http://yhouse_logo.png&apos;,</span><br><span class="line">  content: &apos;内容&apos;</span><br><span class="line">&#125;, </span><br><span class="line">function (responseData) &#123;</span><br><span class="line">  var status = response.statusCode;  // 0-失败，1-成功，2-取消</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>还有个问题是，<strong>这段代码应该在什么时候执行呢？</strong>前面我们提到 <code>WebViewJavascriptBridge</code> 提供了 <code>setupWebViewJavascriptBridge()</code> 函数用于初始化，所以，我们可以在这个函数中进行上面的“转换”。</p>
<h4 id="2-接下来再来看看原生这边的问题，原生如何按照不同页面所需来管理-handler-呢？"><a href="#2-接下来再来看看原生这边的问题，原生如何按照不同页面所需来管理-handler-呢？" class="headerlink" title="2. 接下来再来看看原生这边的问题，原生如何按照不同页面所需来管理 handler 呢？"></a>2. 接下来再来看看原生这边的问题，原生如何按照不同页面所需来管理 handler 呢？</h4><p>我这里采用的是“基础API+特定API”的方式，首先需要定义一个基础的 handler processor，用来管理基础 API 的调用，然后在针对其余一些有特殊逻辑的页面，基于这个 basic handler processor 定义对应的 special handler processor。</p>
<p>另外一个问题是，在打开 <code>WebViewController</code> 时，如何根据不同页面创建对应的 handler processor 呢？一个可行的方式是给每个 有特殊逻辑的页面传入一个 pageId 属性，没有特殊逻辑的页面 pageId 默认为空，<code>WebViewController</code> 维护一张 pageId-handlerProcess 的关系映射表，初始化后再根据这个 pageId 去创建对应的 handler processor 类。</p>
<table>
<thead>
<tr>
<th>page</th>
<th>handlerProcessor</th>
</tr>
</thead>
<tbody>
<tr>
<td>page_id_1</td>
<td>handlerProcessor_1(Based on basicHandlerProcessor)</td>
<td></td>
</tr>
<tr>
<td>page_id_2</td>
<td>handlerProcessor_2(Based on basicHandlerProcessor)</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td>… + baseHandlerProcessor</td>
<td></td>
</tr>
</tbody>
</table>
<p>以下面的 3 个页面为例，这 3 个页面是在同一个 <code>WebViewController</code> 中加载的，其中页面 1 中只有两个基础功能：分享和获取地理位置，页面 2 中相比页面 1 多了一个 拨打电话的功能，页面 3 中相比页面 1 多了一个支付的功能。<br><img src="http://upload-images.jianshu.io/upload_images/814356-43ab390e3b580017.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Example_01"><br><img src="http://upload-images.jianshu.io/upload_images/814356-a4f99ae053a2e945.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Example_02"><br><img src="http://upload-images.jianshu.io/upload_images/814356-f37462d8a04ee4f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Example_03"></p>
<p>首先我们创建一个管理公共 API 的 handler processor <code>SCWebViewMessageHandler</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">@interface SCWebViewMessageHandler : NSObject</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@property (weak, nonatomic) SCWebViewController *controller;</span><br><span class="line"></span><br><span class="line">/// 注册 handler</span><br><span class="line">- (void)registerHandlersForJSBridge:(WebViewJavascriptBridge *)bridge;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/// 要注册的特定 handler name，子类重写</span><br><span class="line">- (NSArray *)specialHandlerNames;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SCWebViewMessageHandler</span><br><span class="line"></span><br><span class="line">- (void)registerHandlersForJSBridge:(WebViewJavascriptBridge *)bridge &#123;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *handlerNames = @[@&quot;requestLocation&quot;, @&quot;share&quot;].mutableCopy;</span><br><span class="line"></span><br><span class="line">    [handlerNames addObjectsFromArray:[self specialHandlerNames]];</span><br><span class="line">    </span><br><span class="line">    for (NSString *aHandlerName in handlerNames) &#123;</span><br><span class="line">        [bridge registerHandler:aHandlerName handler:^(id data, WVJBResponseCallback responseCallback) &#123;</span><br><span class="line">            </span><br><span class="line">            NSMutableDictionary *args = [NSMutableDictionary dictionary];</span><br><span class="line">            </span><br><span class="line">            if ([data isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">                [args addEntriesFromDictionary:data];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (responseCallback) &#123;</span><br><span class="line">                [args setObject:responseCallback forKey:@&quot;responseCallback&quot;];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            NSString *ObjCMethodName = [aHandlerName stringByAppendingString:@&quot;:&quot;];</span><br><span class="line">            </span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">            [self performSelector:NSSelectorFromString(ObjCMethodName) withObject:args];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">            </span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSArray *)specialHandlerNames &#123;</span><br><span class="line">    return @[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Handler Methods</span><br><span class="line"></span><br><span class="line">// 获取地理位置信息</span><br><span class="line">- (void)requestLocation:(NSDictionary *)args &#123;</span><br><span class="line">    WVJBResponseCallback responseCallback = args[@&quot;responseCallback&quot;];</span><br><span class="line">    </span><br><span class="line">    if (responseCallback) &#123;</span><br><span class="line">        </span><br><span class="line">        responseCallback(@&quot;上海市浦东新区张江高科&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 分享</span><br><span class="line">- (void)share:(NSDictionary *)args &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *shareContent = [NSString stringWithFormat:@&quot;标题：%@\n 内容：%@ \n url：%@&quot;,</span><br><span class="line">                              args[@&quot;title&quot;],</span><br><span class="line">                              args[@&quot;content&quot;],</span><br><span class="line">                              args[@&quot;url&quot;]];</span><br><span class="line">    [self.controller showAlertViewWithTitle:@&quot;调用原生分享菜单&quot; message:shareContent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>这个类中主要干三件事，一是获取所有要注册的 handler name，并注册这些 handler；二是通过在 handler回调时，通过 runtime 调用与 handler 同名的 Objective-C 方法，参数只有一个 args，args 中包括两部分，一部分是 JS 传过来的 data，另一部分是回调 JS 的 responseCallback。</p>
<p>子类可以继承该类，通过重写 <code>-specialHandlerNames</code> 方法添加一些特定的 handler name，另外就是实现 handler 对应的 Objective-C  方法。</p>
<p>因此，第一个页面的 handler 可以交给 <code>SCWebViewMessageHandler</code> 处理，第二个页面和第三个页面就需要分别交给子类 <code>SCWebViewSpecialMessageHandlerA</code> 和 <code>SCWebViewSpecialMessageHandlerB</code> 来处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@interface SCWebViewSpecialMessageHandlerA : SCWebViewMessageHandler</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SCWebViewSpecialMessageHandlerA</span><br><span class="line"></span><br><span class="line">- (NSArray *)specialHandlerNames &#123;</span><br><span class="line">    return @[</span><br><span class="line">             @&quot;makeACall&quot;</span><br><span class="line">             ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)makeACall:(NSDictionary *)args &#123;</span><br><span class="line">    [self.controller showAlertViewWithTitle:@&quot;拨打电话&quot; message:args[@&quot;number&quot;]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@interface SCWebViewSpecialMessageHandlerB : SCWebViewMessageHandler</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SCWebViewSpecialMessageHandlerB</span><br><span class="line"></span><br><span class="line">- (NSArray *)specialHandlerNames &#123;</span><br><span class="line">    return @[@&quot;pay&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pay:(NSDictionary *)args &#123;</span><br><span class="line">    NSString *paymentInfo = [NSString stringWithFormat:@&quot;支付方式：%@\n价格：%@&quot;, args[@&quot;type&quot;], args[@&quot;price&quot;]];</span><br><span class="line">    [self.controller showAlertViewWithTitle:@&quot;去支付&quot; message:paymentInfo];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>定义好了这几个处理 handler 的类之后，我们就可以在 <code>WebViewController</code> 中进行相关的配置了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">...</span><br><span class="line">// 根据 pageId，获取对应的 MessageHandler</span><br><span class="line"></span><br><span class="line">// 注册 handler</span><br><span class="line">    SCWebViewMessageHandler *handler = [[self.messageHandlerClass alloc] init];</span><br><span class="line">    handler.controller = self;</span><br><span class="line">    [handler registerHandlersForJSBridge:self.bridge];</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此为止，我们就解决了原生中 handler 管理的问题了。<br>完整示例代码见<a href="https://github.com/ShannonChenCHN/iOSLevelingUp/tree/master/ReadingSourceCode/WebViewJavascriptBridgeNotes/WebViewJavascriptBridge-6.0.2" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="五、问题与讨论"><a href="#五、问题与讨论" class="headerlink" title="五、问题与讨论"></a>五、问题与讨论</h3><ol>
<li><p>已知 bug：在 <code>WKWebView</code> 中使用时，一旦 <code>- webView:decidePolicyForNavigationAction:decisionHandler:</code> 方法被调用，就会出现连续回调两次 <code>decisionHandler</code> 的问题。<br>首先，逻辑上讲，跟 <code>UIWebView</code> 类似，<code>- webView:decidePolicyForNavigationAction:decisionHandler:</code> 方法中的拦截只应该回调一次 <code>decisionHandler</code> 即可。<br>另外，这个问题还会导致应用在 iOS11 + XCode9 的环境下出现崩溃。解决办法见相关 Pull Request <a href="https://github.com/marcuswestin/WebViewJavascriptBridge/pull/296" target="_blank" rel="noopener">#296</a>，期待 maintainer 能够早点 merge。</p>
</li>
<li><p>在加载 <code>WebViewJavascriptBridge_JS</code> 中的 JS 时，就会在创建 <code>messagingIframe</code> 的同时，加载 <code>https://__wvjb_queue_message__</code>，<br>实际上这个时候 <code>sendMessageQueue</code> 数组肯定是空的，也就是说完全不需要发消息，那为什么还要这么做呢？<br>就想问题中所说的，这个时候 <code>sendMessageQueue</code> 数组肯定是空的，因为这个文件加载了，h5 中才会有 <code>WebViewJavascriptBridge</code> 对象，所以，理论上来讲，根本就不存在在这个文件加载前就调用了 <code>WebViewJavascriptBridge.callHandler()</code> 方法的情况。<br>因此，这里的原因肯定不是并不像有些朋友说的“跟 <code>WebViewJavascriptBridgeBase</code> 中的 <code>startupMessageQueue</code>一样，就是在 JavaScript 环境初始化完成以后，把 JavaScript 要发送给 OC 的消息立即发送出去”。<br>通过查找原来版本的提交记录，终于找到了真正的原因，具体见<a href="https://github.com/marcuswestin/WebViewJavascriptBridge/commit/48f88cf07d4eea63d15676b913d3d768041189c7" target="_blank" rel="noopener">相关 commit</a>。</p>
</li>
<li><p>为什么 <code>WebViewJavascriptBridge</code> 中 JS 调用原生时，把要传给原生的数据放到 messageQueue 中，再让原生调 JS 去取，而不是直接拼在 URL 后面？</p>
</li>
<li><p><code>WebViewJavascriptBridge</code> 中加载 URL 调起原生时，为什么不是用 <code>window.location=&quot;https://xxx&quot;</code> 这种形式，而是新添加一个 iframe 来加载这个 URL？<br>因为如果当前页面正在加载时，就有用户操作导致 <code>window.location=&quot;https://xxx&quot;</code> 被触发，这样会使当前页面中还未加载完成的请求被取消掉。</p>
</li>
<li><p>回调的处理<br>其实在 JS 与 Objective-C 通信时，互相传参数并不难，比较难处理的就是回调的处理，<code>WebViewJavascriptBridge</code> 采用的策略是，call 的时候只传 id，callback 本身不传，它在 JS 和 Objective-C 两边，各自维护一个 callback 表，每个 callback 对应一个 id，回调的时候就根据这个 id 去取对应的 callback。<br>在这一点上，跟 React Native 的做法是一样的。</p>
</li>
<li><p><code>WebViewJavascriptBridge</code> 中 web view 执行 JS 脚本时，为什么将其限制在主线程上？</p>
</li>
<li><p>初始化的 JS 内容（也就是 <code>setupWebViewJavascriptBridge</code>函数的定义和调用）是放在 APP bundle 中好呢，还是放到服务器上让 h5 自己去加载好呢？</p>
</li>
<li><p>JS 中的闭包作用域问题<br>在一开始，为了能实现 <code>MyApp.share(data, callback)</code> 的效果，我尝试了下面的这种做法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var handlerNames = new Array(&quot;share&quot;, &quot;requestLocation&quot;);</span><br><span class="line"></span><br><span class="line">for (var i in handlerNames) &#123;</span><br><span class="line">    var handlerName = handlerNames[i];</span><br><span class="line"></span><br><span class="line">    MyApp[handlerName] = Myfunction() &#123;</span><br><span class="line"></span><br><span class="line">            if (typeof data == &quot;function&quot;) &#123; // 意味着没有参数 data，只有一个参数 callback</span><br><span class="line"></span><br><span class="line">                bridge.callHandler(handlerName, null, data);</span><br><span class="line"></span><br><span class="line">            &#125; else if (callback == null) &#123; // 第二个参数 callback 为 null 或者只有第一个参数 data</span><br><span class="line"></span><br><span class="line">                bridge.callHandler(handlerName, data);</span><br><span class="line"></span><br><span class="line">            &#125; else &#123; // 两个参数都有</span><br><span class="line"></span><br><span class="line">                bridge.callHandler(handlerName, data, callback);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>但是，与 Objective-C 中的 block 不同，这里的闭包并没有将外面的 <code>handlerName</code> copy 进去。</p>
<h3 id="六、延伸阅读"><a href="#六、延伸阅读" class="headerlink" title="六、延伸阅读"></a>六、延伸阅读</h3><ul>
<li><a href="https://github.com/marcuswestin/WebViewJavascriptBridge/blob/v6.0.2/README.md" target="_blank" rel="noopener">WebViewJavascriptBridge/README.md</a></li>
<li><a href="http://www.jianshu.com/p/d45ce14278c7" target="_blank" rel="noopener">WebViewJavascriptBridge 原理解析</a></li>
<li><a href="http://www.jianshu.com/p/8bd6aeb719ff" target="_blank" rel="noopener">WebViewJavascriptBridge 机制解析</a></li>
<li><a href="http://qydev.weixin.qq.com/wiki/index.php?title=微信JS-SDK接口&amp;oldid=1667" target="_blank" rel="noopener"> 微信公众号 JS-SDK 文档</a></li>
</ul>
<hr>
<p>欢迎关注公众号：老干部专栏<br><img src="https://shannonchenchn.github.io/assets/img/qrcode_for_gh_cc686217be41_344.jpg" alt="公众号"></p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/01/05/回顾-2017，展望-2018/" class="prev">PREV</a><a href="/2017/07/23/ios-button-image-title-adjust/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">ShannonChenCHN</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>